//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class AlertRequest: APIModel {

    /** The message you want to receive via email or text message */
    public var alertMessage: String?

    /** name of alert */
    public var alertName: String?

    /** whether alert is repeatable or not, so value can only be 0 or 1, this has to be 1 for MTA alert */
    public var alertRepeatable: Int?

    public var conditions: [Conditions]?

    /** email address to receive alert */
    public var email: String?

    /** format, YYYYMMDD-HH:mm:ss, please NOTE this will only work when tif is GTD
 */
    public var expireTime: String?

    /** value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile
 */
    public var iTWSOrdersOnly: Int?

    /** orderId is required when modifying alert. You can get it from /iserver/account/:accountId/alerts
 */
    public var orderId: Int?

    /** value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours.
 */
    public var outsideRth: Int?

    /** audio message to play when alert is triggered */
    public var playAudio: String?

    /** whether allowing to send email or not, so value can only be 0 or 1,
 */
    public var sendMessage: Int?

    /** value can only be 0 or 1, set to 1 to allow to show alert in pop-ups */
    public var showPopup: Int?

    /** time in force, can only be GTC or GTD */
    public var tif: String?

    /** for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert
 */
    public var toolId: Int?

    public class Conditions: APIModel {

        /** format, conid@exchange */
        public var conidex: String?

        /** "a" means "AND", "o" means "OR", "n" means "END",
    the last one condition in the condition array should "n"
     */
        public var logicBind: String?

        /** optional, operator for the current condition, can be >= or <= */
        public var `operator`: String?

        /** only needed for some MTA alert condition */
        public var timeZone: String?

        /** optional, only some type of conditions have triggerMethod */
        public var triggerMethod: String?

        /** Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN&
     */
        public var type: Int?

        /** can not be empty, can pass default value "*" */
        public var value: String?

        public init(conidex: String? = nil, logicBind: String? = nil, `operator`: String? = nil, timeZone: String? = nil, triggerMethod: String? = nil, type: Int? = nil, value: String? = nil) {
            self.conidex = conidex
            self.logicBind = logicBind
            self.`operator` = `operator`
            self.timeZone = timeZone
            self.triggerMethod = triggerMethod
            self.type = type
            self.value = value
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            conidex = try container.decodeIfPresent("conidex")
            logicBind = try container.decodeIfPresent("logicBind")
            `operator` = try container.decodeIfPresent("operator")
            timeZone = try container.decodeIfPresent("timeZone")
            triggerMethod = try container.decodeIfPresent("triggerMethod")
            type = try container.decodeIfPresent("type")
            value = try container.decodeIfPresent("value")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(conidex, forKey: "conidex")
            try container.encodeIfPresent(logicBind, forKey: "logicBind")
            try container.encodeIfPresent(`operator`, forKey: "operator")
            try container.encodeIfPresent(timeZone, forKey: "timeZone")
            try container.encodeIfPresent(triggerMethod, forKey: "triggerMethod")
            try container.encodeIfPresent(type, forKey: "type")
            try container.encodeIfPresent(value, forKey: "value")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Conditions else { return false }
          guard self.conidex == object.conidex else { return false }
          guard self.logicBind == object.logicBind else { return false }
          guard self.`operator` == object.`operator` else { return false }
          guard self.timeZone == object.timeZone else { return false }
          guard self.triggerMethod == object.triggerMethod else { return false }
          guard self.type == object.type else { return false }
          guard self.value == object.value else { return false }
          return true
        }

        public static func == (lhs: Conditions, rhs: Conditions) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(alertMessage: String? = nil, alertName: String? = nil, alertRepeatable: Int? = nil, conditions: [Conditions]? = nil, email: String? = nil, expireTime: String? = nil, iTWSOrdersOnly: Int? = nil, orderId: Int? = nil, outsideRth: Int? = nil, playAudio: String? = nil, sendMessage: Int? = nil, showPopup: Int? = nil, tif: String? = nil, toolId: Int? = nil) {
        self.alertMessage = alertMessage
        self.alertName = alertName
        self.alertRepeatable = alertRepeatable
        self.conditions = conditions
        self.email = email
        self.expireTime = expireTime
        self.iTWSOrdersOnly = iTWSOrdersOnly
        self.orderId = orderId
        self.outsideRth = outsideRth
        self.playAudio = playAudio
        self.sendMessage = sendMessage
        self.showPopup = showPopup
        self.tif = tif
        self.toolId = toolId
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        alertMessage = try container.decodeIfPresent("alertMessage")
        alertName = try container.decodeIfPresent("alertName")
        alertRepeatable = try container.decodeIfPresent("alertRepeatable")
        conditions = try container.decodeArrayIfPresent("conditions")
        email = try container.decodeIfPresent("email")
        expireTime = try container.decodeIfPresent("expireTime")
        iTWSOrdersOnly = try container.decodeIfPresent("iTWSOrdersOnly")
        orderId = try container.decodeIfPresent("orderId")
        outsideRth = try container.decodeIfPresent("outsideRth")
        playAudio = try container.decodeIfPresent("playAudio")
        sendMessage = try container.decodeIfPresent("sendMessage")
        showPopup = try container.decodeIfPresent("showPopup")
        tif = try container.decodeIfPresent("tif")
        toolId = try container.decodeIfPresent("toolId")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(alertMessage, forKey: "alertMessage")
        try container.encodeIfPresent(alertName, forKey: "alertName")
        try container.encodeIfPresent(alertRepeatable, forKey: "alertRepeatable")
        try container.encodeIfPresent(conditions, forKey: "conditions")
        try container.encodeIfPresent(email, forKey: "email")
        try container.encodeIfPresent(expireTime, forKey: "expireTime")
        try container.encodeIfPresent(iTWSOrdersOnly, forKey: "iTWSOrdersOnly")
        try container.encodeIfPresent(orderId, forKey: "orderId")
        try container.encodeIfPresent(outsideRth, forKey: "outsideRth")
        try container.encodeIfPresent(playAudio, forKey: "playAudio")
        try container.encodeIfPresent(sendMessage, forKey: "sendMessage")
        try container.encodeIfPresent(showPopup, forKey: "showPopup")
        try container.encodeIfPresent(tif, forKey: "tif")
        try container.encodeIfPresent(toolId, forKey: "toolId")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? AlertRequest else { return false }
      guard self.alertMessage == object.alertMessage else { return false }
      guard self.alertName == object.alertName else { return false }
      guard self.alertRepeatable == object.alertRepeatable else { return false }
      guard self.conditions == object.conditions else { return false }
      guard self.email == object.email else { return false }
      guard self.expireTime == object.expireTime else { return false }
      guard self.iTWSOrdersOnly == object.iTWSOrdersOnly else { return false }
      guard self.orderId == object.orderId else { return false }
      guard self.outsideRth == object.outsideRth else { return false }
      guard self.playAudio == object.playAudio else { return false }
      guard self.sendMessage == object.sendMessage else { return false }
      guard self.showPopup == object.showPopup else { return false }
      guard self.tif == object.tif else { return false }
      guard self.toolId == object.toolId else { return false }
      return true
    }

    public static func == (lhs: AlertRequest, rhs: AlertRequest) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
