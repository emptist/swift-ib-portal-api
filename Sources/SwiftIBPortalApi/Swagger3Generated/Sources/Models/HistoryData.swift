//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class HistoryData: APIModel {

    /** The number of seconds in a bar */
    public var barLength: Int?

    public var data: [DataType]?

    /** High value during this time series with format %h/%v/%t. %h is the high price (scaled by priceFactor), %v is volume
(volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart
 */
    public var high: String?

    /** Low value during this time series with format %l/%v/%t. %l is the low price (scaled by priceFactor), %v is volume
(volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart
 */
    public var low: String?

    /** Market Data Availability. The field may contain two chars. The first char is the primary code: S = Streaming, R = Realtime, D = Delayed,
Z = Frozen, Y = Frozen Delayed. The second char is the secondary code: P = Snapshot Available, p = Consolidated.
 */
    public var mdAvailability: String?

    public var messageVersion: Int?

    /** The time it takes, in milliseconds, to process the historical data request */
    public var mktDataDelay: Int?

    public var negativeCapable: Bool?

    /** The historical data returned includes outside of regular trading hours
 */
    public var outsideRth: Bool?

    /** total number of points */
    public var points: Int?

    public var priceDisplayRule: Int?

    public var priceDisplayValue: String?

    /** priceFactor is price increment obtained from display rule */
    public var priceFactor: Int?

    /** start date time in the format YYYYMMDD-HH:mm:ss */
    public var startTime: String?

    /** Underlying Symbol of the corresponding contract */
    public var symbol: String?

    /** companyName of the corresponding contract */
    public var text: String?

    /** The duration for the historical data request */
    public var timePeriod: String?

    /** The number of seconds in the trading day */
    public var tradingDayDuration: Int?

    public var travelTime: Int?

    public var volumeFactor: Int?

    public class DataType: APIModel {

        /** close price */
        public var c: Double?

        /** high price */
        public var h: Double?

        /** low price */
        public var l: Double?

        /** open price */
        public var o: Double?

        /** unix time stamp */
        public var t: Double?

        /** volume */
        public var v: Double?

        public init(c: Double? = nil, h: Double? = nil, l: Double? = nil, o: Double? = nil, t: Double? = nil, v: Double? = nil) {
            self.c = c
            self.h = h
            self.l = l
            self.o = o
            self.t = t
            self.v = v
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            c = try container.decodeIfPresent("c")
            h = try container.decodeIfPresent("h")
            l = try container.decodeIfPresent("l")
            o = try container.decodeIfPresent("o")
            t = try container.decodeIfPresent("t")
            v = try container.decodeIfPresent("v")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(c, forKey: "c")
            try container.encodeIfPresent(h, forKey: "h")
            try container.encodeIfPresent(l, forKey: "l")
            try container.encodeIfPresent(o, forKey: "o")
            try container.encodeIfPresent(t, forKey: "t")
            try container.encodeIfPresent(v, forKey: "v")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? DataType else { return false }
          guard self.c == object.c else { return false }
          guard self.h == object.h else { return false }
          guard self.l == object.l else { return false }
          guard self.o == object.o else { return false }
          guard self.t == object.t else { return false }
          guard self.v == object.v else { return false }
          return true
        }

        public static func == (lhs: DataType, rhs: DataType) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(barLength: Int? = nil, data: [DataType]? = nil, high: String? = nil, low: String? = nil, mdAvailability: String? = nil, messageVersion: Int? = nil, mktDataDelay: Int? = nil, negativeCapable: Bool? = nil, outsideRth: Bool? = nil, points: Int? = nil, priceDisplayRule: Int? = nil, priceDisplayValue: String? = nil, priceFactor: Int? = nil, startTime: String? = nil, symbol: String? = nil, text: String? = nil, timePeriod: String? = nil, tradingDayDuration: Int? = nil, travelTime: Int? = nil, volumeFactor: Int? = nil) {
        self.barLength = barLength
        self.data = data
        self.high = high
        self.low = low
        self.mdAvailability = mdAvailability
        self.messageVersion = messageVersion
        self.mktDataDelay = mktDataDelay
        self.negativeCapable = negativeCapable
        self.outsideRth = outsideRth
        self.points = points
        self.priceDisplayRule = priceDisplayRule
        self.priceDisplayValue = priceDisplayValue
        self.priceFactor = priceFactor
        self.startTime = startTime
        self.symbol = symbol
        self.text = text
        self.timePeriod = timePeriod
        self.tradingDayDuration = tradingDayDuration
        self.travelTime = travelTime
        self.volumeFactor = volumeFactor
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        barLength = try container.decodeIfPresent("barLength")
        data = try container.decodeArrayIfPresent("data")
        high = try container.decodeIfPresent("high")
        low = try container.decodeIfPresent("low")
        mdAvailability = try container.decodeIfPresent("mdAvailability")
        messageVersion = try container.decodeIfPresent("messageVersion")
        mktDataDelay = try container.decodeIfPresent("mktDataDelay")
        negativeCapable = try container.decodeIfPresent("negativeCapable")
        outsideRth = try container.decodeIfPresent("outsideRth")
        points = try container.decodeIfPresent("points")
        priceDisplayRule = try container.decodeIfPresent("priceDisplayRule")
        priceDisplayValue = try container.decodeIfPresent("priceDisplayValue")
        priceFactor = try container.decodeIfPresent("priceFactor")
        startTime = try container.decodeIfPresent("startTime")
        symbol = try container.decodeIfPresent("symbol")
        text = try container.decodeIfPresent("text")
        timePeriod = try container.decodeIfPresent("timePeriod")
        tradingDayDuration = try container.decodeIfPresent("tradingDayDuration")
        travelTime = try container.decodeIfPresent("travelTime")
        volumeFactor = try container.decodeIfPresent("volumeFactor")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(barLength, forKey: "barLength")
        try container.encodeIfPresent(data, forKey: "data")
        try container.encodeIfPresent(high, forKey: "high")
        try container.encodeIfPresent(low, forKey: "low")
        try container.encodeIfPresent(mdAvailability, forKey: "mdAvailability")
        try container.encodeIfPresent(messageVersion, forKey: "messageVersion")
        try container.encodeIfPresent(mktDataDelay, forKey: "mktDataDelay")
        try container.encodeIfPresent(negativeCapable, forKey: "negativeCapable")
        try container.encodeIfPresent(outsideRth, forKey: "outsideRth")
        try container.encodeIfPresent(points, forKey: "points")
        try container.encodeIfPresent(priceDisplayRule, forKey: "priceDisplayRule")
        try container.encodeIfPresent(priceDisplayValue, forKey: "priceDisplayValue")
        try container.encodeIfPresent(priceFactor, forKey: "priceFactor")
        try container.encodeIfPresent(startTime, forKey: "startTime")
        try container.encodeIfPresent(symbol, forKey: "symbol")
        try container.encodeIfPresent(text, forKey: "text")
        try container.encodeIfPresent(timePeriod, forKey: "timePeriod")
        try container.encodeIfPresent(tradingDayDuration, forKey: "tradingDayDuration")
        try container.encodeIfPresent(travelTime, forKey: "travelTime")
        try container.encodeIfPresent(volumeFactor, forKey: "volumeFactor")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? HistoryData else { return false }
      guard self.barLength == object.barLength else { return false }
      guard self.data == object.data else { return false }
      guard self.high == object.high else { return false }
      guard self.low == object.low else { return false }
      guard self.mdAvailability == object.mdAvailability else { return false }
      guard self.messageVersion == object.messageVersion else { return false }
      guard self.mktDataDelay == object.mktDataDelay else { return false }
      guard self.negativeCapable == object.negativeCapable else { return false }
      guard self.outsideRth == object.outsideRth else { return false }
      guard self.points == object.points else { return false }
      guard self.priceDisplayRule == object.priceDisplayRule else { return false }
      guard self.priceDisplayValue == object.priceDisplayValue else { return false }
      guard self.priceFactor == object.priceFactor else { return false }
      guard self.startTime == object.startTime else { return false }
      guard self.symbol == object.symbol else { return false }
      guard self.text == object.text else { return false }
      guard self.timePeriod == object.timePeriod else { return false }
      guard self.tradingDayDuration == object.tradingDayDuration else { return false }
      guard self.travelTime == object.travelTime else { return false }
      guard self.volumeFactor == object.volumeFactor else { return false }
      return true
    }

    public static func == (lhs: HistoryData, rhs: HistoryData) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
