//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class AlertResponse: APIModel {

    /** account id */
    public var account: String?

    /** whether alert is active or not, so value can only be 0 or 1 */
    public var alertActive: Int?

    /** MTA alert only */
    public var alertDefaultType: String?

    /** email address to receive alert */
    public var alertEmail: String?

    /** The message you want to receive via email or text message */
    public var alertMessage: String?

    /** MTA alert only */
    public var alertMtaCurrency: String?

    /** MTA alert only */
    public var alertMtaDefaults: String?

    /** name of alert */
    public var alertName: String?

    /** audio message to play when alert is triggered */
    public var alertPlayAudio: String?

    /** whether alert is repeatable or not, so value can only be 0 or 1 */
    public var alertRepeatable: Int?

    /** whether allowing to send email or not, so value can only be 0 or 1,
 */
    public var alertSendMessage: Int?

    /** value can only be 0 or 1, set to 1 to allow to show alert in pop-ups */
    public var alertShowPopup: Int?

    /** whether the alert has been triggered */
    public var alertTriggered: Bool?

    /** whether allowing the condition can be triggered outside of regular trading hours, 1 means allow */
    public var conditionOutsideRth: Int?

    /** size of conditions array */
    public var conditionSize: Int?

    public var conditions: [Conditions]?

    /** format, YYYYMMDD-HH:mm:ss
 */
    public var expireTime: String?

    /** value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile
 */
    public var itwsOrdersOnly: Int?

    public var orderId: Int?

    /** whether the alert can be edited */
    public var orderNotEditable: Bool?

    /** status of alert */
    public var orderStatus: String?

    /** value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours.
 */
    public var outsideRth: Int?

    /** time in force, can only be GTC or GTD */
    public var tif: String?

    /** MTA alert only */
    public var timeZone: String?

    /** for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert
 */
    public var toolId: Int?

    public class Conditions: APIModel {

        /** "a" means "AND", "o" means "OR", "n" means "END",
    the last one condition in the condition array should "n"
     */
        public var conditionLogicBind: String?

        /** optional, operator for the current condition, can be >= or <= */
        public var conditionOperator: String?

        /** only needed for some MTA alert condition */
        public var conditionTimeZone: String?

        /** optional, only some type of conditions have triggerMethod */
        public var conditionTriggerMethod: String?

        /** Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN&
     */
        public var conditionType: Int?

        /** can not be empty, can pass default value "*" */
        public var conditionValue: String?

        /** format, conid@exchange */
        public var conidex: String?

        public var contractDescription1: String?

        public init(conditionLogicBind: String? = nil, conditionOperator: String? = nil, conditionTimeZone: String? = nil, conditionTriggerMethod: String? = nil, conditionType: Int? = nil, conditionValue: String? = nil, conidex: String? = nil, contractDescription1: String? = nil) {
            self.conditionLogicBind = conditionLogicBind
            self.conditionOperator = conditionOperator
            self.conditionTimeZone = conditionTimeZone
            self.conditionTriggerMethod = conditionTriggerMethod
            self.conditionType = conditionType
            self.conditionValue = conditionValue
            self.conidex = conidex
            self.contractDescription1 = contractDescription1
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            conditionLogicBind = try container.decodeIfPresent("condition_logic_bind")
            conditionOperator = try container.decodeIfPresent("condition_operator")
            conditionTimeZone = try container.decodeIfPresent("condition_time_zone")
            conditionTriggerMethod = try container.decodeIfPresent("condition_trigger_method")
            conditionType = try container.decodeIfPresent("condition_type")
            conditionValue = try container.decodeIfPresent("condition_value")
            conidex = try container.decodeIfPresent("conidex")
            contractDescription1 = try container.decodeIfPresent("contract_description_1")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(conditionLogicBind, forKey: "condition_logic_bind")
            try container.encodeIfPresent(conditionOperator, forKey: "condition_operator")
            try container.encodeIfPresent(conditionTimeZone, forKey: "condition_time_zone")
            try container.encodeIfPresent(conditionTriggerMethod, forKey: "condition_trigger_method")
            try container.encodeIfPresent(conditionType, forKey: "condition_type")
            try container.encodeIfPresent(conditionValue, forKey: "condition_value")
            try container.encodeIfPresent(conidex, forKey: "conidex")
            try container.encodeIfPresent(contractDescription1, forKey: "contract_description_1")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Conditions else { return false }
          guard self.conditionLogicBind == object.conditionLogicBind else { return false }
          guard self.conditionOperator == object.conditionOperator else { return false }
          guard self.conditionTimeZone == object.conditionTimeZone else { return false }
          guard self.conditionTriggerMethod == object.conditionTriggerMethod else { return false }
          guard self.conditionType == object.conditionType else { return false }
          guard self.conditionValue == object.conditionValue else { return false }
          guard self.conidex == object.conidex else { return false }
          guard self.contractDescription1 == object.contractDescription1 else { return false }
          return true
        }

        public static func == (lhs: Conditions, rhs: Conditions) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(account: String? = nil, alertActive: Int? = nil, alertDefaultType: String? = nil, alertEmail: String? = nil, alertMessage: String? = nil, alertMtaCurrency: String? = nil, alertMtaDefaults: String? = nil, alertName: String? = nil, alertPlayAudio: String? = nil, alertRepeatable: Int? = nil, alertSendMessage: Int? = nil, alertShowPopup: Int? = nil, alertTriggered: Bool? = nil, conditionOutsideRth: Int? = nil, conditionSize: Int? = nil, conditions: [Conditions]? = nil, expireTime: String? = nil, itwsOrdersOnly: Int? = nil, orderId: Int? = nil, orderNotEditable: Bool? = nil, orderStatus: String? = nil, outsideRth: Int? = nil, tif: String? = nil, timeZone: String? = nil, toolId: Int? = nil) {
        self.account = account
        self.alertActive = alertActive
        self.alertDefaultType = alertDefaultType
        self.alertEmail = alertEmail
        self.alertMessage = alertMessage
        self.alertMtaCurrency = alertMtaCurrency
        self.alertMtaDefaults = alertMtaDefaults
        self.alertName = alertName
        self.alertPlayAudio = alertPlayAudio
        self.alertRepeatable = alertRepeatable
        self.alertSendMessage = alertSendMessage
        self.alertShowPopup = alertShowPopup
        self.alertTriggered = alertTriggered
        self.conditionOutsideRth = conditionOutsideRth
        self.conditionSize = conditionSize
        self.conditions = conditions
        self.expireTime = expireTime
        self.itwsOrdersOnly = itwsOrdersOnly
        self.orderId = orderId
        self.orderNotEditable = orderNotEditable
        self.orderStatus = orderStatus
        self.outsideRth = outsideRth
        self.tif = tif
        self.timeZone = timeZone
        self.toolId = toolId
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        account = try container.decodeIfPresent("account")
        alertActive = try container.decodeIfPresent("alert_active")
        alertDefaultType = try container.decodeIfPresent("alert_default_type")
        alertEmail = try container.decodeIfPresent("alert_email")
        alertMessage = try container.decodeIfPresent("alert_message")
        alertMtaCurrency = try container.decodeIfPresent("alert_mta_currency")
        alertMtaDefaults = try container.decodeIfPresent("alert_mta_defaults")
        alertName = try container.decodeIfPresent("alert_name")
        alertPlayAudio = try container.decodeIfPresent("alert_play_audio")
        alertRepeatable = try container.decodeIfPresent("alert_repeatable")
        alertSendMessage = try container.decodeIfPresent("alert_send_message")
        alertShowPopup = try container.decodeIfPresent("alert_show_popup")
        alertTriggered = try container.decodeIfPresent("alert_triggered")
        conditionOutsideRth = try container.decodeIfPresent("condition_outside_rth")
        conditionSize = try container.decodeIfPresent("condition_size")
        conditions = try container.decodeArrayIfPresent("conditions")
        expireTime = try container.decodeIfPresent("expire_time")
        itwsOrdersOnly = try container.decodeIfPresent("itws_orders_only")
        orderId = try container.decodeIfPresent("order_id")
        orderNotEditable = try container.decodeIfPresent("order_not_editable")
        orderStatus = try container.decodeIfPresent("order_status")
        outsideRth = try container.decodeIfPresent("outsideRth")
        tif = try container.decodeIfPresent("tif")
        timeZone = try container.decodeIfPresent("time_zone")
        toolId = try container.decodeIfPresent("tool_id")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(account, forKey: "account")
        try container.encodeIfPresent(alertActive, forKey: "alert_active")
        try container.encodeIfPresent(alertDefaultType, forKey: "alert_default_type")
        try container.encodeIfPresent(alertEmail, forKey: "alert_email")
        try container.encodeIfPresent(alertMessage, forKey: "alert_message")
        try container.encodeIfPresent(alertMtaCurrency, forKey: "alert_mta_currency")
        try container.encodeIfPresent(alertMtaDefaults, forKey: "alert_mta_defaults")
        try container.encodeIfPresent(alertName, forKey: "alert_name")
        try container.encodeIfPresent(alertPlayAudio, forKey: "alert_play_audio")
        try container.encodeIfPresent(alertRepeatable, forKey: "alert_repeatable")
        try container.encodeIfPresent(alertSendMessage, forKey: "alert_send_message")
        try container.encodeIfPresent(alertShowPopup, forKey: "alert_show_popup")
        try container.encodeIfPresent(alertTriggered, forKey: "alert_triggered")
        try container.encodeIfPresent(conditionOutsideRth, forKey: "condition_outside_rth")
        try container.encodeIfPresent(conditionSize, forKey: "condition_size")
        try container.encodeIfPresent(conditions, forKey: "conditions")
        try container.encodeIfPresent(expireTime, forKey: "expire_time")
        try container.encodeIfPresent(itwsOrdersOnly, forKey: "itws_orders_only")
        try container.encodeIfPresent(orderId, forKey: "order_id")
        try container.encodeIfPresent(orderNotEditable, forKey: "order_not_editable")
        try container.encodeIfPresent(orderStatus, forKey: "order_status")
        try container.encodeIfPresent(outsideRth, forKey: "outsideRth")
        try container.encodeIfPresent(tif, forKey: "tif")
        try container.encodeIfPresent(timeZone, forKey: "time_zone")
        try container.encodeIfPresent(toolId, forKey: "tool_id")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? AlertResponse else { return false }
      guard self.account == object.account else { return false }
      guard self.alertActive == object.alertActive else { return false }
      guard self.alertDefaultType == object.alertDefaultType else { return false }
      guard self.alertEmail == object.alertEmail else { return false }
      guard self.alertMessage == object.alertMessage else { return false }
      guard self.alertMtaCurrency == object.alertMtaCurrency else { return false }
      guard self.alertMtaDefaults == object.alertMtaDefaults else { return false }
      guard self.alertName == object.alertName else { return false }
      guard self.alertPlayAudio == object.alertPlayAudio else { return false }
      guard self.alertRepeatable == object.alertRepeatable else { return false }
      guard self.alertSendMessage == object.alertSendMessage else { return false }
      guard self.alertShowPopup == object.alertShowPopup else { return false }
      guard self.alertTriggered == object.alertTriggered else { return false }
      guard self.conditionOutsideRth == object.conditionOutsideRth else { return false }
      guard self.conditionSize == object.conditionSize else { return false }
      guard self.conditions == object.conditions else { return false }
      guard self.expireTime == object.expireTime else { return false }
      guard self.itwsOrdersOnly == object.itwsOrdersOnly else { return false }
      guard self.orderId == object.orderId else { return false }
      guard self.orderNotEditable == object.orderNotEditable else { return false }
      guard self.orderStatus == object.orderStatus else { return false }
      guard self.outsideRth == object.outsideRth else { return false }
      guard self.tif == object.tif else { return false }
      guard self.timeZone == object.timeZone else { return false }
      guard self.toolId == object.toolId else { return false }
      return true
    }

    public static func == (lhs: AlertResponse, rhs: AlertResponse) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
