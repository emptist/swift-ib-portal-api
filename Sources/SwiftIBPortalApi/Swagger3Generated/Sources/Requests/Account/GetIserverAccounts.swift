//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Account {

    /**
    Brokerage Accounts

    Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
    */
    public enum GetIserverAccounts {

        public static let service = APIService<Response>(id: "getIserverAccounts", tag: "Account", method: "GET", path: "/iserver/accounts", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public init() {
                super.init(service: GetIserverAccounts.service)
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders. */
            public class Status200: APIModel {

                /** Unique account id */
                public var accounts: [String]?

                /** Account Id and its alias */
                public var aliases: [String: Any]?

                public var selectedAccount: String?

                public init(accounts: [String]? = nil, aliases: [String: Any]? = nil, selectedAccount: String? = nil) {
                    self.accounts = accounts
                    self.aliases = aliases
                    self.selectedAccount = selectedAccount
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    accounts = try container.decodeArrayIfPresent("accounts")
                    aliases = try container.decodeAnyIfPresent("aliases")
                    selectedAccount = try container.decodeIfPresent("selectedAccount")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(accounts, forKey: "accounts")
                    try container.encodeAnyIfPresent(aliases, forKey: "aliases")
                    try container.encodeIfPresent(selectedAccount, forKey: "selectedAccount")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.accounts == object.accounts else { return false }
                  guard NSDictionary(dictionary: self.aliases ?? [:]).isEqual(to: object.aliases ?? [:]) else { return false }
                  guard self.selectedAccount == object.selectedAccount else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** An array of accounts */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
