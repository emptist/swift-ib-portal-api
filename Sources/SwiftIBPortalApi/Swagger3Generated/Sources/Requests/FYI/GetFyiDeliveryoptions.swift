//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.FYI {

    /**
    Get delivery options

    options for sending fyis to email and other devices
    */
    public enum GetFyiDeliveryoptions {

        public static let service = APIService<Response>(id: "getFyiDeliveryoptions", tag: "FYI", method: "GET", path: "/fyi/deliveryoptions", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public init() {
                super.init(service: GetFyiDeliveryoptions.service)
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** options for sending fyis to email and other devices
             */
            public class Status200: APIModel {

                public var e: [E]?

                /** Email option is enabled or not 0-off, 1-on. */
                public var m: Int?

                /** device */
                public class E: APIModel {

                    /** device is enabled or not 0-true, 1-false. */
                    public var a: String?

                    /** device id */
                    public var i: String?

                    /** device name */
                    public var nm: String?

                    /** unique device id */
                    public var ui: String?

                    public init(a: String? = nil, i: String? = nil, nm: String? = nil, ui: String? = nil) {
                        self.a = a
                        self.i = i
                        self.nm = nm
                        self.ui = ui
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        a = try container.decodeIfPresent("A")
                        i = try container.decodeIfPresent("I")
                        nm = try container.decodeIfPresent("NM")
                        ui = try container.decodeIfPresent("UI")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(a, forKey: "A")
                        try container.encodeIfPresent(i, forKey: "I")
                        try container.encodeIfPresent(nm, forKey: "NM")
                        try container.encodeIfPresent(ui, forKey: "UI")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? E else { return false }
                      guard self.a == object.a else { return false }
                      guard self.i == object.i else { return false }
                      guard self.nm == object.nm else { return false }
                      guard self.ui == object.ui else { return false }
                      return true
                    }

                    public static func == (lhs: E, rhs: E) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(e: [E]? = nil, m: Int? = nil) {
                    self.e = e
                    self.m = m
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    e = try container.decodeArrayIfPresent("E")
                    m = try container.decodeIfPresent("M")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(e, forKey: "E")
                    try container.encodeIfPresent(m, forKey: "M")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.e == object.e else { return false }
                  guard self.m == object.m else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** An object */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
