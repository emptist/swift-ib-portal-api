//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Order {

    /**
    Place Order

    Please note here, sometimes this endpoint alone can't make sure you submit the order successfully,
you could receive some questions in the response, you have to to answer them in order to submit the order
successfully. You can use "/iserver/reply/{replyid}" endpoint to answer questions
    */
    public enum PostIserverAccountByAccountIdOrder {

        public static let service = APIService<Response>(id: "postIserverAccountByAccountIdOrder", tag: "Order", method: "POST", path: "/iserver/account/{accountId}/order", hasBody: true, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** account id */
                public var accountId: String

                public init(accountId: String) {
                    self.accountId = accountId
                }
            }

            public var options: Options

            public var body: OrderRequest

            public init(body: OrderRequest, options: Options, encoder: RequestEncoder? = nil) {
                self.body = body
                self.options = options
                super.init(service: PostIserverAccountByAccountIdOrder.service) { defaultEncoder in
                    return try (encoder ?? defaultEncoder).encode(body)
                }
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(accountId: String, body: OrderRequest) {
                let options = Options(accountId: accountId)
                self.init(body: body, options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "accountId" + "}", with: "\(self.options.accountId)")
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Please note here, sometimes this endpoint alone can't make sure you submit the order successfully,
            you could receive some questions in the response, you have to to answer them in order to submit the order
            successfully. You can use "/iserver/reply/{replyid}" endpoint to answer questions
             */
            public class Status200: APIModel {

                public var id: String?

                /** Please note here, if the message is a question, you have to reply to question in order to submit
            the order successfully. See more in the "/iserver/reply/{replyid}" endpoint.
             */
                public var message: [String]?

                public init(id: String? = nil, message: [String]? = nil) {
                    self.id = id
                    self.message = message
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    id = try container.decodeIfPresent("id")
                    message = try container.decodeArrayIfPresent("message")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(id, forKey: "id")
                    try container.encodeIfPresent(message, forKey: "message")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.id == object.id else { return false }
                  guard self.message == object.message else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = [Status200]

            /** returns an array */
            case status200([Status200])

            public var success: [Status200]? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode([Status200].self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
