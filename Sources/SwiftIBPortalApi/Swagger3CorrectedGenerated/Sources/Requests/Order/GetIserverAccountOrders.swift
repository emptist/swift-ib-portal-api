//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension IBPortalApi.Order {

    /**
    Live Orders

    The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
The response will contain two objects, one is notification, the other is orders. 
Orders is the list of live orders (cancelled, filled, submitted). 
Notifications contains information about execute orders as they happen, see status field.
To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
    */
    public enum GetIserverAccountOrders {

        public static let service = APIService<Response>(id: "getIserverAccountOrders", tag: "Order", method: "GET", path: "/iserver/account/orders", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public init() {
                super.init(service: GetIserverAccountOrders.service)
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
            The response will contain two objects, one is notification, the other is orders. 
            Orders is the list of live orders (cancelled, filled, submitted). 
            Notifications contains information about execute orders as they happen, see status field.
            To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
             */
            public struct Status200: APIModel {

                public let orders: [Orders]?

                /** If live order update is a snapshot */
                public let snapshot: Bool?

                /** The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
                The response will contain two objects, one is notification, the other is orders. 
                Orders is the list of live orders (cancelled, filled, submitted). 
                Notifications contains information about execute orders as they happen, see status field.
                To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
                 */
                public struct Orders: APIModel {

                    /** Account number */
                    public let acct: String?

                    /** background color in hex format */
                    public let bgColor: String?

                    /** Cash currency */
                    public let cashCcy: String?

                    /** Company Name */
                    public let companyName: String?

                    /** Contract identifier */
                    public let conid: Double?

                    /** Formatted ticker description */
                    public let description1: String?

                    /** Exchange or trading venue */
                    public let exchange: String?

                    /** foreground color in hex format */
                    public let fgColor: String?

                    /** Quantity filled */
                    public let filledQuantity: Double?

                    /** Last status update in format YYMMDDhhmms based in GMT */
                    public let lastExecutionTime: Double?

                    /** Last status update unix time in ms */
                    public let lastExecutionTimer: Double?

                    /** Listing Exchange */
                    public let listingExchange: String?

                    /** Order description */
                    public let orderDesc: String?

                    /** Order identifier */
                    public let orderId: String?

                    /** Order type */
                    public let orderType: String?

                    /** Order reference */
                    public let orderRef: String?

                    /** Original order type */
                    public let origOrderType: String?

                    /** Price of order */
                    public let price: Double?

                    /** Quantity remaining */
                    public let remainingQuantity: Double?

                    /** Asset class */
                    public let secType: String?

                    /** Side of order */
                    public let side: String?

                    /** Quantity outstanding and total quantity concatenated with forward slash separator */
                    public let sizeAndFills: Double?

                    /** Status of the order */
                    public let status: String?

                    /** Supports Tax Optimization with 0 for no and 1 for yes */
                    public let supportsTaxOpt: Double?

                    /** Underlying symbol */
                    public let ticker: String?

                    /** Time in force */
                    public let timeInForce: String?

                    public init(acct: String? = nil, bgColor: String? = nil, cashCcy: String? = nil, companyName: String? = nil, conid: Double? = nil, description1: String? = nil, exchange: String? = nil, fgColor: String? = nil, filledQuantity: Double? = nil, lastExecutionTime: Double? = nil, lastExecutionTimer: Double? = nil, listingExchange: String? = nil, orderDesc: String? = nil, orderId: String? = nil, orderType: String? = nil, orderRef: String? = nil, origOrderType: String? = nil, price: Double? = nil, remainingQuantity: Double? = nil, secType: String? = nil, side: String? = nil, sizeAndFills: Double? = nil, status: String? = nil, supportsTaxOpt: Double? = nil, ticker: String? = nil, timeInForce: String? = nil) {
                        self.acct = acct
                        self.bgColor = bgColor
                        self.cashCcy = cashCcy
                        self.companyName = companyName
                        self.conid = conid
                        self.description1 = description1
                        self.exchange = exchange
                        self.fgColor = fgColor
                        self.filledQuantity = filledQuantity
                        self.lastExecutionTime = lastExecutionTime
                        self.lastExecutionTimer = lastExecutionTimer
                        self.listingExchange = listingExchange
                        self.orderDesc = orderDesc
                        self.orderId = orderId
                        self.orderType = orderType
                        self.orderRef = orderRef
                        self.origOrderType = origOrderType
                        self.price = price
                        self.remainingQuantity = remainingQuantity
                        self.secType = secType
                        self.side = side
                        self.sizeAndFills = sizeAndFills
                        self.status = status
                        self.supportsTaxOpt = supportsTaxOpt
                        self.ticker = ticker
                        self.timeInForce = timeInForce
                    }

                    public init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        acct = try container.decodeIfPresent("acct")
                        bgColor = try container.decodeIfPresent("bgColor")
                        cashCcy = try container.decodeIfPresent("cashCcy")
                        companyName = try container.decodeIfPresent("companyName")
                        conid = try container.decodeIfPresent("conid")
                        description1 = try container.decodeIfPresent("description1")
                        exchange = try container.decodeIfPresent("exchange")
                        fgColor = try container.decodeIfPresent("fgColor")
                        filledQuantity = try container.decodeIfPresent("filledQuantity")
                        lastExecutionTime = try container.decodeIfPresent("lastExecutionTime")
                        lastExecutionTimer = try container.decodeIfPresent("lastExecutionTime_r")
                        listingExchange = try container.decodeIfPresent("listingExchange")
                        orderDesc = try container.decodeIfPresent("orderDesc")
                        orderId = try container.decodeIfPresent("orderId")
                        orderType = try container.decodeIfPresent("orderType")
                        orderRef = try container.decodeIfPresent("order_ref")
                        origOrderType = try container.decodeIfPresent("origOrderType")
                        price = try container.decodeIfPresent("price")
                        remainingQuantity = try container.decodeIfPresent("remainingQuantity")
                        secType = try container.decodeIfPresent("secType")
                        side = try container.decodeIfPresent("side")
                        sizeAndFills = try container.decodeIfPresent("sizeAndFills")
                        status = try container.decodeIfPresent("status")
                        supportsTaxOpt = try container.decodeIfPresent("supportsTaxOpt")
                        ticker = try container.decodeIfPresent("ticker")
                        timeInForce = try container.decodeIfPresent("timeInForce")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(acct, forKey: "acct")
                        try container.encodeIfPresent(bgColor, forKey: "bgColor")
                        try container.encodeIfPresent(cashCcy, forKey: "cashCcy")
                        try container.encodeIfPresent(companyName, forKey: "companyName")
                        try container.encodeIfPresent(conid, forKey: "conid")
                        try container.encodeIfPresent(description1, forKey: "description1")
                        try container.encodeIfPresent(exchange, forKey: "exchange")
                        try container.encodeIfPresent(fgColor, forKey: "fgColor")
                        try container.encodeIfPresent(filledQuantity, forKey: "filledQuantity")
                        try container.encodeIfPresent(lastExecutionTime, forKey: "lastExecutionTime")
                        try container.encodeIfPresent(lastExecutionTimer, forKey: "lastExecutionTime_r")
                        try container.encodeIfPresent(listingExchange, forKey: "listingExchange")
                        try container.encodeIfPresent(orderDesc, forKey: "orderDesc")
                        try container.encodeIfPresent(orderId, forKey: "orderId")
                        try container.encodeIfPresent(orderType, forKey: "orderType")
                        try container.encodeIfPresent(orderRef, forKey: "order_ref")
                        try container.encodeIfPresent(origOrderType, forKey: "origOrderType")
                        try container.encodeIfPresent(price, forKey: "price")
                        try container.encodeIfPresent(remainingQuantity, forKey: "remainingQuantity")
                        try container.encodeIfPresent(secType, forKey: "secType")
                        try container.encodeIfPresent(side, forKey: "side")
                        try container.encodeIfPresent(sizeAndFills, forKey: "sizeAndFills")
                        try container.encodeIfPresent(status, forKey: "status")
                        try container.encodeIfPresent(supportsTaxOpt, forKey: "supportsTaxOpt")
                        try container.encodeIfPresent(ticker, forKey: "ticker")
                        try container.encodeIfPresent(timeInForce, forKey: "timeInForce")
                    }

                }

                public init(orders: [Orders]? = nil, snapshot: Bool? = nil) {
                    self.orders = orders
                    self.snapshot = snapshot
                }

                public init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    orders = try container.decodeArrayIfPresent("orders")
                    snapshot = try container.decodeIfPresent("snapshot")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(orders, forKey: "orders")
                    try container.encodeIfPresent(snapshot, forKey: "snapshot")
                }

            }
            public typealias SuccessType = Status200

            /** An object contains two arrays */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
