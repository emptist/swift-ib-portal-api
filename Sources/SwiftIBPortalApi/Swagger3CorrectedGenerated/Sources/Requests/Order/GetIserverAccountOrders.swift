//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Order {

    /**
    Live Orders

    The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
The response will contain two objects, one is notification, the other is orders. 
Orders is the list of live orders (cancelled, filled, submitted). 
Notifications contains information about execute orders as they happen, see status field.
To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
    */
    public enum GetIserverAccountOrders {

        public static let service = APIService<Response>(id: "getIserverAccountOrders", tag: "Order", method: "GET", path: "/iserver/account/orders", hasBody: true, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            /** The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
            The response will contain two objects, one is notification, the other is orders. 
            Orders is the list of live orders (cancelled, filled, submitted). 
            Notifications contains information about execute orders as they happen, see status field.
            To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
             */
            public class Body: APIModel {

                public var filters: [String]?

                public init(filters: [String]? = nil) {
                    self.filters = filters
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    filters = try container.decodeArrayIfPresent("filters")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(filters, forKey: "filters")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Body else { return false }
                  guard self.filters == object.filters else { return false }
                  return true
                }

                public static func == (lhs: Body, rhs: Body) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public struct Options {

                public var filters: [String]?

                public init(filters: [String]? = nil) {
                    self.filters = filters
                }
            }

            public var options: Options

            public var body: Body?

            public init(body: Body?, options: Options, encoder: RequestEncoder? = nil) {
                self.body = body
                self.options = options
                super.init(service: GetIserverAccountOrders.service) { defaultEncoder in
                    return try (encoder ?? defaultEncoder).encode(body)
                }
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(filters: [String]? = nil, body: Body? = nil) {
                let options = Options(filters: filters)
                self.init(body: body, options: options)
            }

            public override var formParameters: [String: Any] {
                var params: [String: Any] = [:]
                if let filters = options.filters {
                  params["filters"] = filters
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
            The response will contain two objects, one is notification, the other is orders. 
            Orders is the list of live orders (cancelled, filled, submitted). 
            Notifications contains information about execute orders as they happen, see status field.
            To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
             */
            public class Status200: APIModel {

                public var orders: [Orders]?

                /** If live order update is a snapshot */
                public var snapshot: Bool?

                /** The endpoint is meant to be used in polling mode, e.g. requesting every x seconds.
                The response will contain two objects, one is notification, the other is orders. 
                Orders is the list of live orders (cancelled, filled, submitted). 
                Notifications contains information about execute orders as they happen, see status field.
                To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
                 */
                public class Orders: APIModel {

                    /** Account number */
                    public var acct: String?

                    /** background color in hex format */
                    public var bgColor: String?

                    /** Cash currency */
                    public var cashCcy: String?

                    /** Company Name */
                    public var companyName: String?

                    /** Contract identifier */
                    public var conid: Double?

                    /** Formatted ticker description */
                    public var description1: String?

                    /** Exchange or trading venue */
                    public var exchange: String?

                    /** foreground color in hex format */
                    public var fgColor: String?

                    /** Quantity filled */
                    public var filledQuantity: Double?

                    /** Last status update in format YYMMDDhhmms based in GMT */
                    public var lastExecutionTime: Double?

                    /** Last status update unix time in ms */
                    public var lastExecutionTimer: Double?

                    /** Listing Exchange */
                    public var listingExchange: String?

                    /** Order description */
                    public var orderDesc: String?

                    /** Order identifier */
                    public var orderId: String?

                    /** Order type */
                    public var orderType: String?

                    /** Order reference */
                    public var orderRef: String?

                    /** Original order type */
                    public var origOrderType: String?

                    /** Price of order */
                    public var price: Double?

                    /** Quantity remaining */
                    public var remainingQuantity: Double?

                    /** Asset class */
                    public var secType: String?

                    /** Side of order */
                    public var side: String?

                    /** Quantity outstanding and total quantity concatenated with forward slash separator */
                    public var sizeAndFills: Double?

                    /** Status of the order */
                    public var status: String?

                    /** Supports Tax Optimization with 0 for no and 1 for yes */
                    public var supportsTaxOpt: Double?

                    /** Underlying symbol */
                    public var ticker: String?

                    /** Time in force */
                    public var timeInForce: String?

                    public init(acct: String? = nil, bgColor: String? = nil, cashCcy: String? = nil, companyName: String? = nil, conid: Double? = nil, description1: String? = nil, exchange: String? = nil, fgColor: String? = nil, filledQuantity: Double? = nil, lastExecutionTime: Double? = nil, lastExecutionTimer: Double? = nil, listingExchange: String? = nil, orderDesc: String? = nil, orderId: String? = nil, orderType: String? = nil, orderRef: String? = nil, origOrderType: String? = nil, price: Double? = nil, remainingQuantity: Double? = nil, secType: String? = nil, side: String? = nil, sizeAndFills: Double? = nil, status: String? = nil, supportsTaxOpt: Double? = nil, ticker: String? = nil, timeInForce: String? = nil) {
                        self.acct = acct
                        self.bgColor = bgColor
                        self.cashCcy = cashCcy
                        self.companyName = companyName
                        self.conid = conid
                        self.description1 = description1
                        self.exchange = exchange
                        self.fgColor = fgColor
                        self.filledQuantity = filledQuantity
                        self.lastExecutionTime = lastExecutionTime
                        self.lastExecutionTimer = lastExecutionTimer
                        self.listingExchange = listingExchange
                        self.orderDesc = orderDesc
                        self.orderId = orderId
                        self.orderType = orderType
                        self.orderRef = orderRef
                        self.origOrderType = origOrderType
                        self.price = price
                        self.remainingQuantity = remainingQuantity
                        self.secType = secType
                        self.side = side
                        self.sizeAndFills = sizeAndFills
                        self.status = status
                        self.supportsTaxOpt = supportsTaxOpt
                        self.ticker = ticker
                        self.timeInForce = timeInForce
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        acct = try container.decodeIfPresent("acct")
                        bgColor = try container.decodeIfPresent("bgColor")
                        cashCcy = try container.decodeIfPresent("cashCcy")
                        companyName = try container.decodeIfPresent("companyName")
                        conid = try container.decodeIfPresent("conid")
                        description1 = try container.decodeIfPresent("description1")
                        exchange = try container.decodeIfPresent("exchange")
                        fgColor = try container.decodeIfPresent("fgColor")
                        filledQuantity = try container.decodeIfPresent("filledQuantity")
                        lastExecutionTime = try container.decodeIfPresent("lastExecutionTime")
                        lastExecutionTimer = try container.decodeIfPresent("lastExecutionTime_r")
                        listingExchange = try container.decodeIfPresent("listingExchange")
                        orderDesc = try container.decodeIfPresent("orderDesc")
                        orderId = try container.decodeIfPresent("orderId")
                        orderType = try container.decodeIfPresent("orderType")
                        orderRef = try container.decodeIfPresent("order_ref")
                        origOrderType = try container.decodeIfPresent("origOrderType")
                        price = try container.decodeIfPresent("price")
                        remainingQuantity = try container.decodeIfPresent("remainingQuantity")
                        secType = try container.decodeIfPresent("secType")
                        side = try container.decodeIfPresent("side")
                        sizeAndFills = try container.decodeIfPresent("sizeAndFills")
                        status = try container.decodeIfPresent("status")
                        supportsTaxOpt = try container.decodeIfPresent("supportsTaxOpt")
                        ticker = try container.decodeIfPresent("ticker")
                        timeInForce = try container.decodeIfPresent("timeInForce")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(acct, forKey: "acct")
                        try container.encodeIfPresent(bgColor, forKey: "bgColor")
                        try container.encodeIfPresent(cashCcy, forKey: "cashCcy")
                        try container.encodeIfPresent(companyName, forKey: "companyName")
                        try container.encodeIfPresent(conid, forKey: "conid")
                        try container.encodeIfPresent(description1, forKey: "description1")
                        try container.encodeIfPresent(exchange, forKey: "exchange")
                        try container.encodeIfPresent(fgColor, forKey: "fgColor")
                        try container.encodeIfPresent(filledQuantity, forKey: "filledQuantity")
                        try container.encodeIfPresent(lastExecutionTime, forKey: "lastExecutionTime")
                        try container.encodeIfPresent(lastExecutionTimer, forKey: "lastExecutionTime_r")
                        try container.encodeIfPresent(listingExchange, forKey: "listingExchange")
                        try container.encodeIfPresent(orderDesc, forKey: "orderDesc")
                        try container.encodeIfPresent(orderId, forKey: "orderId")
                        try container.encodeIfPresent(orderType, forKey: "orderType")
                        try container.encodeIfPresent(orderRef, forKey: "order_ref")
                        try container.encodeIfPresent(origOrderType, forKey: "origOrderType")
                        try container.encodeIfPresent(price, forKey: "price")
                        try container.encodeIfPresent(remainingQuantity, forKey: "remainingQuantity")
                        try container.encodeIfPresent(secType, forKey: "secType")
                        try container.encodeIfPresent(side, forKey: "side")
                        try container.encodeIfPresent(sizeAndFills, forKey: "sizeAndFills")
                        try container.encodeIfPresent(status, forKey: "status")
                        try container.encodeIfPresent(supportsTaxOpt, forKey: "supportsTaxOpt")
                        try container.encodeIfPresent(ticker, forKey: "ticker")
                        try container.encodeIfPresent(timeInForce, forKey: "timeInForce")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Orders else { return false }
                      guard self.acct == object.acct else { return false }
                      guard self.bgColor == object.bgColor else { return false }
                      guard self.cashCcy == object.cashCcy else { return false }
                      guard self.companyName == object.companyName else { return false }
                      guard self.conid == object.conid else { return false }
                      guard self.description1 == object.description1 else { return false }
                      guard self.exchange == object.exchange else { return false }
                      guard self.fgColor == object.fgColor else { return false }
                      guard self.filledQuantity == object.filledQuantity else { return false }
                      guard self.lastExecutionTime == object.lastExecutionTime else { return false }
                      guard self.lastExecutionTimer == object.lastExecutionTimer else { return false }
                      guard self.listingExchange == object.listingExchange else { return false }
                      guard self.orderDesc == object.orderDesc else { return false }
                      guard self.orderId == object.orderId else { return false }
                      guard self.orderType == object.orderType else { return false }
                      guard self.orderRef == object.orderRef else { return false }
                      guard self.origOrderType == object.origOrderType else { return false }
                      guard self.price == object.price else { return false }
                      guard self.remainingQuantity == object.remainingQuantity else { return false }
                      guard self.secType == object.secType else { return false }
                      guard self.side == object.side else { return false }
                      guard self.sizeAndFills == object.sizeAndFills else { return false }
                      guard self.status == object.status else { return false }
                      guard self.supportsTaxOpt == object.supportsTaxOpt else { return false }
                      guard self.ticker == object.ticker else { return false }
                      guard self.timeInForce == object.timeInForce else { return false }
                      return true
                    }

                    public static func == (lhs: Orders, rhs: Orders) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(orders: [Orders]? = nil, snapshot: Bool? = nil) {
                    self.orders = orders
                    self.snapshot = snapshot
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    orders = try container.decodeArrayIfPresent("orders")
                    snapshot = try container.decodeIfPresent("snapshot")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(orders, forKey: "orders")
                    try container.encodeIfPresent(snapshot, forKey: "snapshot")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.orders == object.orders else { return false }
                  guard self.snapshot == object.snapshot else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** An object contains two arrays */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
