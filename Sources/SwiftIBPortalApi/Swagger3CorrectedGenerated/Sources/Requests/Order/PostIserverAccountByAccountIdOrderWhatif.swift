//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Order {

    /**
    Preview Order

    This endpoint allows you to preview order without actually submitting the order and you can get
commission information in the response.
    */
    public enum PostIserverAccountByAccountIdOrderWhatif {

        public static let service = APIService<Response>(id: "postIserverAccountByAccountIdOrderWhatif", tag: "Order", method: "POST", path: "/iserver/account/{accountId}/order/whatif", hasBody: true, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** account id */
                public var accountId: String

                public init(accountId: String) {
                    self.accountId = accountId
                }
            }

            public var options: Options

            public var body: OrderRequest

            public init(body: OrderRequest, options: Options, encoder: RequestEncoder? = nil) {
                self.body = body
                self.options = options
                super.init(service: PostIserverAccountByAccountIdOrderWhatif.service) { defaultEncoder in
                    return try (encoder ?? defaultEncoder).encode(body)
                }
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(accountId: String, body: OrderRequest) {
                let options = Options(accountId: accountId)
                self.init(body: body, options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "accountId" + "}", with: "\(self.options.accountId)")
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** This endpoint allows you to preview order without actually submitting the order and you can get
            commission information in the response.
             */
            public class Status200: APIModel {

                public var amount: Amount?

                public var equity: Equity?

                public var error: String?

                public var initial: Initial?

                public var maintenance: Maintenance?

                public var warn: String?

                /** This endpoint allows you to preview order without actually submitting the order and you can get
                commission information in the response.
                 */
                public class Amount: APIModel {

                    /** for example 23,000 USD */
                    public var amount: String?

                    /** for example 1.1 ... 1.2 USD */
                    public var commission: String?

                    public var total: String?

                    public init(amount: String? = nil, commission: String? = nil, total: String? = nil) {
                        self.amount = amount
                        self.commission = commission
                        self.total = total
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        amount = try container.decodeIfPresent("amount")
                        commission = try container.decodeIfPresent("commission")
                        total = try container.decodeIfPresent("total")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(amount, forKey: "amount")
                        try container.encodeIfPresent(commission, forKey: "commission")
                        try container.encodeIfPresent(total, forKey: "total")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Amount else { return false }
                      guard self.amount == object.amount else { return false }
                      guard self.commission == object.commission else { return false }
                      guard self.total == object.total else { return false }
                      return true
                    }

                    public static func == (lhs: Amount, rhs: Amount) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** This endpoint allows you to preview order without actually submitting the order and you can get
                commission information in the response.
                 */
                public class Equity: APIModel {

                    public var after: String?

                    public var change: String?

                    public var current: String?

                    public init(after: String? = nil, change: String? = nil, current: String? = nil) {
                        self.after = after
                        self.change = change
                        self.current = current
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        after = try container.decodeIfPresent("after")
                        change = try container.decodeIfPresent("change")
                        current = try container.decodeIfPresent("current")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(after, forKey: "after")
                        try container.encodeIfPresent(change, forKey: "change")
                        try container.encodeIfPresent(current, forKey: "current")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Equity else { return false }
                      guard self.after == object.after else { return false }
                      guard self.change == object.change else { return false }
                      guard self.current == object.current else { return false }
                      return true
                    }

                    public static func == (lhs: Equity, rhs: Equity) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** This endpoint allows you to preview order without actually submitting the order and you can get
                commission information in the response.
                 */
                public class Initial: APIModel {

                    public var after: String?

                    public var change: String?

                    public var current: String?

                    public init(after: String? = nil, change: String? = nil, current: String? = nil) {
                        self.after = after
                        self.change = change
                        self.current = current
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        after = try container.decodeIfPresent("after")
                        change = try container.decodeIfPresent("change")
                        current = try container.decodeIfPresent("current")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(after, forKey: "after")
                        try container.encodeIfPresent(change, forKey: "change")
                        try container.encodeIfPresent(current, forKey: "current")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Initial else { return false }
                      guard self.after == object.after else { return false }
                      guard self.change == object.change else { return false }
                      guard self.current == object.current else { return false }
                      return true
                    }

                    public static func == (lhs: Initial, rhs: Initial) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** This endpoint allows you to preview order without actually submitting the order and you can get
                commission information in the response.
                 */
                public class Maintenance: APIModel {

                    public var after: String?

                    public var change: String?

                    public var current: String?

                    public init(after: String? = nil, change: String? = nil, current: String? = nil) {
                        self.after = after
                        self.change = change
                        self.current = current
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        after = try container.decodeIfPresent("after")
                        change = try container.decodeIfPresent("change")
                        current = try container.decodeIfPresent("current")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(after, forKey: "after")
                        try container.encodeIfPresent(change, forKey: "change")
                        try container.encodeIfPresent(current, forKey: "current")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Maintenance else { return false }
                      guard self.after == object.after else { return false }
                      guard self.change == object.change else { return false }
                      guard self.current == object.current else { return false }
                      return true
                    }

                    public static func == (lhs: Maintenance, rhs: Maintenance) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(amount: Amount? = nil, equity: Equity? = nil, error: String? = nil, initial: Initial? = nil, maintenance: Maintenance? = nil, warn: String? = nil) {
                    self.amount = amount
                    self.equity = equity
                    self.error = error
                    self.initial = initial
                    self.maintenance = maintenance
                    self.warn = warn
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    amount = try container.decodeIfPresent("amount")
                    equity = try container.decodeIfPresent("equity")
                    error = try container.decodeIfPresent("error")
                    initial = try container.decodeIfPresent("initial")
                    maintenance = try container.decodeIfPresent("maintenance")
                    warn = try container.decodeIfPresent("warn")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(amount, forKey: "amount")
                    try container.encodeIfPresent(equity, forKey: "equity")
                    try container.encodeIfPresent(error, forKey: "error")
                    try container.encodeIfPresent(initial, forKey: "initial")
                    try container.encodeIfPresent(maintenance, forKey: "maintenance")
                    try container.encodeIfPresent(warn, forKey: "warn")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.amount == object.amount else { return false }
                  guard self.equity == object.equity else { return false }
                  guard self.error == object.error else { return false }
                  guard self.initial == object.initial else { return false }
                  guard self.maintenance == object.maintenance else { return false }
                  guard self.warn == object.warn else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** returns an object */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
