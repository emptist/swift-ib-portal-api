//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Contract {

    /**
    Get trading schedule for symbol

    Returns the trading schedule up to a month for the requested contract
    */
    public enum GetTrsrvSecdefSchedule {

        public static let service = APIService<Response>(id: "getTrsrvSecdefSchedule", tag: "Contract", method: "GET", path: "/trsrv/secdef/schedule", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** specify the asset class of the contract.
Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
 */
                public var assetClass: String

                /** Underlying Symbol for specified contract, for example 'AAPL' for US Stock - Apple Inc. */
                public var symbol: String

                /** Native exchange for contract, for example 'NASDAQ' for US Stock - Apple Inc. */
                public var exchange: String?

                public init(assetClass: String, symbol: String, exchange: String? = nil) {
                    self.assetClass = assetClass
                    self.symbol = symbol
                    self.exchange = exchange
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: GetTrsrvSecdefSchedule.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(assetClass: String, symbol: String, exchange: String? = nil) {
                let options = Options(assetClass: assetClass, symbol: symbol, exchange: exchange)
                self.init(options: options)
            }

            public override var queryParameters: [String: Any] {
                var params: [String: Any] = [:]
                params["assetClass"] = options.assetClass
                params["symbol"] = options.symbol
                if let exchange = options.exchange {
                  params["exchange"] = exchange
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Returns the trading schedule up to a month for the requested contract */
            public class Status200: APIModel {

                public var id: String?

                /** Always contains at least one 'tradingTime'  and zero or more 'sessionTime' tags */
                public var schedules: [Schedules]?

                /** null is returned. */
                public var tradeVenueId: String?

                /** Returns the trading schedule up to a month for the requested contract */
                public class Schedules: APIModel {

                    public var clearingCycleEndTime: Int?

                    /** If the LIQUID hours differs from the total trading day then a separate 'session' tag is returned. */
                    public var sessions: Sessions?

                    /** 20000101 stands for any Sat, 20000102 stands for any Sun, ... 20000107 stands for any Fri. Any other date stands for itself. */
                    public var tradingScheduleDate: Int?

                    /** Returns tradingTime in exchange time zone. */
                    public var tradingTimes: TradingTimes?

                    /** If the LIQUID hours differs from the total trading day then a separate 'session' tag is returned. */
                    public class Sessions: APIModel {

                        public var closingTime: Int?

                        public var openingTime: Int?

                        /** If the whole trading day is considered LIQUID then the value 'LIQUID' is returned. */
                        public var prop: String?

                        public init(closingTime: Int? = nil, openingTime: Int? = nil, prop: String? = nil) {
                            self.closingTime = closingTime
                            self.openingTime = openingTime
                            self.prop = prop
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            closingTime = try container.decodeIfPresent("closingTime")
                            openingTime = try container.decodeIfPresent("openingTime")
                            prop = try container.decodeIfPresent("prop")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(closingTime, forKey: "closingTime")
                            try container.encodeIfPresent(openingTime, forKey: "openingTime")
                            try container.encodeIfPresent(prop, forKey: "prop")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Sessions else { return false }
                          guard self.closingTime == object.closingTime else { return false }
                          guard self.openingTime == object.openingTime else { return false }
                          guard self.prop == object.prop else { return false }
                          return true
                        }

                        public static func == (lhs: Sessions, rhs: Sessions) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Returns tradingTime in exchange time zone. */
                    public class TradingTimes: APIModel {

                        public var cancelDayOrders: String?

                        public var closingTime: Int?

                        public var openingTime: Int?

                        public init(cancelDayOrders: String? = nil, closingTime: Int? = nil, openingTime: Int? = nil) {
                            self.cancelDayOrders = cancelDayOrders
                            self.closingTime = closingTime
                            self.openingTime = openingTime
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            cancelDayOrders = try container.decodeIfPresent("cancelDayOrders")
                            closingTime = try container.decodeIfPresent("closingTime")
                            openingTime = try container.decodeIfPresent("openingTime")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(cancelDayOrders, forKey: "cancelDayOrders")
                            try container.encodeIfPresent(closingTime, forKey: "closingTime")
                            try container.encodeIfPresent(openingTime, forKey: "openingTime")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? TradingTimes else { return false }
                          guard self.cancelDayOrders == object.cancelDayOrders else { return false }
                          guard self.closingTime == object.closingTime else { return false }
                          guard self.openingTime == object.openingTime else { return false }
                          return true
                        }

                        public static func == (lhs: TradingTimes, rhs: TradingTimes) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(clearingCycleEndTime: Int? = nil, sessions: Sessions? = nil, tradingScheduleDate: Int? = nil, tradingTimes: TradingTimes? = nil) {
                        self.clearingCycleEndTime = clearingCycleEndTime
                        self.sessions = sessions
                        self.tradingScheduleDate = tradingScheduleDate
                        self.tradingTimes = tradingTimes
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        clearingCycleEndTime = try container.decodeIfPresent("clearingCycleEndTime")
                        sessions = try container.decodeIfPresent("sessions")
                        tradingScheduleDate = try container.decodeIfPresent("tradingScheduleDate")
                        tradingTimes = try container.decodeIfPresent("tradingTimes")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(clearingCycleEndTime, forKey: "clearingCycleEndTime")
                        try container.encodeIfPresent(sessions, forKey: "sessions")
                        try container.encodeIfPresent(tradingScheduleDate, forKey: "tradingScheduleDate")
                        try container.encodeIfPresent(tradingTimes, forKey: "tradingTimes")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Schedules else { return false }
                      guard self.clearingCycleEndTime == object.clearingCycleEndTime else { return false }
                      guard self.sessions == object.sessions else { return false }
                      guard self.tradingScheduleDate == object.tradingScheduleDate else { return false }
                      guard self.tradingTimes == object.tradingTimes else { return false }
                      return true
                    }

                    public static func == (lhs: Schedules, rhs: Schedules) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(id: String? = nil, schedules: [Schedules]? = nil, tradeVenueId: String? = nil) {
                    self.id = id
                    self.schedules = schedules
                    self.tradeVenueId = tradeVenueId
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    id = try container.decodeIfPresent("id")
                    schedules = try container.decodeArrayIfPresent("schedules")
                    tradeVenueId = try container.decodeIfPresent("tradeVenueId")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(id, forKey: "id")
                    try container.encodeIfPresent(schedules, forKey: "schedules")
                    try container.encodeIfPresent(tradeVenueId, forKey: "tradeVenueId")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.id == object.id else { return false }
                  guard self.schedules == object.schedules else { return false }
                  guard self.tradeVenueId == object.tradeVenueId else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** Returns an object */
            case status200(Status200)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
