//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.IBCust {

    /**
    IBCust Entity Info

    Returns Applicant Id with all owner related entities
    */
    public enum GetIbcustEntityInfo {

        public static let service = APIService<Response>(id: "getIbcustEntityInfo", tag: "IBCust", method: "GET", path: "/ibcust/entity/info", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public init() {
                super.init(service: GetIbcustEntityInfo.service)
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Returns Applicant Id with all owner related entities */
            public class Status200: APIModel {

                public var applicantId: Double?

                public var entities: [Entities]?

                /** Returns Applicant Id with all owner related entities */
                public class Entities: APIModel {

                    public var address: Address?

                    public var canSign: Bool?

                    public var canTrade: Bool?

                    public var identDocs: [[String: Any]]?

                    public var name: Name?

                    public var type: String?

                    /** Returns Applicant Id with all owner related entities */
                    public class Address: APIModel {

                        public var city: String?

                        public var compact: String?

                        public var country: String?

                        public var countryCode: String?

                        public var postalCode: String?

                        public var state: String?

                        public var street: String?

                        public var street2: String?

                        public init(city: String? = nil, compact: String? = nil, country: String? = nil, countryCode: String? = nil, postalCode: String? = nil, state: String? = nil, street: String? = nil, street2: String? = nil) {
                            self.city = city
                            self.compact = compact
                            self.country = country
                            self.countryCode = countryCode
                            self.postalCode = postalCode
                            self.state = state
                            self.street = street
                            self.street2 = street2
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            city = try container.decodeIfPresent("city")
                            compact = try container.decodeIfPresent("compact")
                            country = try container.decodeIfPresent("country")
                            countryCode = try container.decodeIfPresent("countryCode")
                            postalCode = try container.decodeIfPresent("postalCode")
                            state = try container.decodeIfPresent("state")
                            street = try container.decodeIfPresent("street")
                            street2 = try container.decodeIfPresent("street2")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(city, forKey: "city")
                            try container.encodeIfPresent(compact, forKey: "compact")
                            try container.encodeIfPresent(country, forKey: "country")
                            try container.encodeIfPresent(countryCode, forKey: "countryCode")
                            try container.encodeIfPresent(postalCode, forKey: "postalCode")
                            try container.encodeIfPresent(state, forKey: "state")
                            try container.encodeIfPresent(street, forKey: "street")
                            try container.encodeIfPresent(street2, forKey: "street2")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Address else { return false }
                          guard self.city == object.city else { return false }
                          guard self.compact == object.compact else { return false }
                          guard self.country == object.country else { return false }
                          guard self.countryCode == object.countryCode else { return false }
                          guard self.postalCode == object.postalCode else { return false }
                          guard self.state == object.state else { return false }
                          guard self.street == object.street else { return false }
                          guard self.street2 == object.street2 else { return false }
                          return true
                        }

                        public static func == (lhs: Address, rhs: Address) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Returns Applicant Id with all owner related entities */
                    public class Name: APIModel {

                        public var firstName: String?

                        public var lastName: String?

                        public var salutation: String?

                        public init(firstName: String? = nil, lastName: String? = nil, salutation: String? = nil) {
                            self.firstName = firstName
                            self.lastName = lastName
                            self.salutation = salutation
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            firstName = try container.decodeIfPresent("firstName")
                            lastName = try container.decodeIfPresent("lastName")
                            salutation = try container.decodeIfPresent("salutation")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(firstName, forKey: "firstName")
                            try container.encodeIfPresent(lastName, forKey: "lastName")
                            try container.encodeIfPresent(salutation, forKey: "salutation")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Name else { return false }
                          guard self.firstName == object.firstName else { return false }
                          guard self.lastName == object.lastName else { return false }
                          guard self.salutation == object.salutation else { return false }
                          return true
                        }

                        public static func == (lhs: Name, rhs: Name) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(address: Address? = nil, canSign: Bool? = nil, canTrade: Bool? = nil, identDocs: [[String: Any]]? = nil, name: Name? = nil, type: String? = nil) {
                        self.address = address
                        self.canSign = canSign
                        self.canTrade = canTrade
                        self.identDocs = identDocs
                        self.name = name
                        self.type = type
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        address = try container.decodeIfPresent("address")
                        canSign = try container.decodeIfPresent("canSign")
                        canTrade = try container.decodeIfPresent("canTrade")
                        identDocs = try container.decodeAnyIfPresent("identDocs")
                        name = try container.decodeIfPresent("name")
                        type = try container.decodeIfPresent("type")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(address, forKey: "address")
                        try container.encodeIfPresent(canSign, forKey: "canSign")
                        try container.encodeIfPresent(canTrade, forKey: "canTrade")
                        try container.encodeAnyIfPresent(identDocs, forKey: "identDocs")
                        try container.encodeIfPresent(name, forKey: "name")
                        try container.encodeIfPresent(type, forKey: "type")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Entities else { return false }
                      guard self.address == object.address else { return false }
                      guard self.canSign == object.canSign else { return false }
                      guard self.canTrade == object.canTrade else { return false }
                      guard self.identDocs == object.identDocs else { return false }
                      guard self.name == object.name else { return false }
                      guard self.type == object.type else { return false }
                      return true
                    }

                    public static func == (lhs: Entities, rhs: Entities) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(applicantId: Double? = nil, entities: [Entities]? = nil) {
                    self.applicantId = applicantId
                    self.entities = entities
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    applicantId = try container.decodeIfPresent("applicantId")
                    entities = try container.decodeArrayIfPresent("entities")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(applicantId, forKey: "applicantId")
                    try container.encodeIfPresent(entities, forKey: "entities")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.applicantId == object.applicantId else { return false }
                  guard self.entities == object.entities else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = [Status200]

            /** Search result */
            case status200([Status200])

            public var success: [Status200]? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode([Status200].self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
