//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension IBPortalApi.IBCust {

    /**
    IBCust Entity Info

    Returns Applicant Id with all owner related entities
    */
    public enum GetIbcustEntityInfo {

        public static let service = APIService<Response>(id: "getIbcustEntityInfo", tag: "IBCust", method: "GET", path: "/ibcust/entity/info", hasBody: false, securityRequirements: [])

        public final class Request: APIRequest<Response> {

            public init() {
                super.init(service: GetIbcustEntityInfo.service)
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Returns Applicant Id with all owner related entities */
            public struct Status200: APIModel {

                public let applicantId: Double?

                public let entities: [Entities]?

                /** Returns Applicant Id with all owner related entities */
                public struct Entities: APIModel {

                    public let address: Address?

                    public let canSign: Bool?

                    public let canTrade: Bool?

                    public let identDocs: [[String: AnyCodable]]?

                    public let name: Name?

                    public let type: String?

                    /** Returns Applicant Id with all owner related entities */
                    public struct Address: APIModel {

                        public let city: String?

                        public let compact: String?

                        public let country: String?

                        public let countryCode: String?

                        public let postalCode: String?

                        public let state: String?

                        public let street: String?

                        public let street2: String?

                        public init(city: String? = nil, compact: String? = nil, country: String? = nil, countryCode: String? = nil, postalCode: String? = nil, state: String? = nil, street: String? = nil, street2: String? = nil) {
                            self.city = city
                            self.compact = compact
                            self.country = country
                            self.countryCode = countryCode
                            self.postalCode = postalCode
                            self.state = state
                            self.street = street
                            self.street2 = street2
                        }

                        public init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            city = try container.decodeIfPresent("city")
                            compact = try container.decodeIfPresent("compact")
                            country = try container.decodeIfPresent("country")
                            countryCode = try container.decodeIfPresent("countryCode")
                            postalCode = try container.decodeIfPresent("postalCode")
                            state = try container.decodeIfPresent("state")
                            street = try container.decodeIfPresent("street")
                            street2 = try container.decodeIfPresent("street2")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(city, forKey: "city")
                            try container.encodeIfPresent(compact, forKey: "compact")
                            try container.encodeIfPresent(country, forKey: "country")
                            try container.encodeIfPresent(countryCode, forKey: "countryCode")
                            try container.encodeIfPresent(postalCode, forKey: "postalCode")
                            try container.encodeIfPresent(state, forKey: "state")
                            try container.encodeIfPresent(street, forKey: "street")
                            try container.encodeIfPresent(street2, forKey: "street2")
                        }

                    }

                    /** Returns Applicant Id with all owner related entities */
                    public struct Name: APIModel {

                        public let firstName: String?

                        public let lastName: String?

                        public let salutation: String?

                        public init(firstName: String? = nil, lastName: String? = nil, salutation: String? = nil) {
                            self.firstName = firstName
                            self.lastName = lastName
                            self.salutation = salutation
                        }

                        public init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            firstName = try container.decodeIfPresent("firstName")
                            lastName = try container.decodeIfPresent("lastName")
                            salutation = try container.decodeIfPresent("salutation")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(firstName, forKey: "firstName")
                            try container.encodeIfPresent(lastName, forKey: "lastName")
                            try container.encodeIfPresent(salutation, forKey: "salutation")
                        }

                    }

                    public init(address: Address? = nil, canSign: Bool? = nil, canTrade: Bool? = nil, identDocs: [[String: AnyCodable]]? = nil, name: Name? = nil, type: String? = nil) {
                        self.address = address
                        self.canSign = canSign
                        self.canTrade = canTrade
                        self.identDocs = identDocs
                        self.name = name
                        self.type = type
                    }

                    public init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        address = try container.decodeIfPresent("address")
                        canSign = try container.decodeIfPresent("canSign")
                        canTrade = try container.decodeIfPresent("canTrade")
                        identDocs = try container.decodeAnyIfPresent("identDocs")
                        name = try container.decodeIfPresent("name")
                        type = try container.decodeIfPresent("type")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(address, forKey: "address")
                        try container.encodeIfPresent(canSign, forKey: "canSign")
                        try container.encodeIfPresent(canTrade, forKey: "canTrade")
                        try container.encodeAnyIfPresent(identDocs, forKey: "identDocs")
                        try container.encodeIfPresent(name, forKey: "name")
                        try container.encodeIfPresent(type, forKey: "type")
                    }

                }

                public init(applicantId: Double? = nil, entities: [Entities]? = nil) {
                    self.applicantId = applicantId
                    self.entities = entities
                }

                public init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    applicantId = try container.decodeIfPresent("applicantId")
                    entities = try container.decodeArrayIfPresent("entities")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(applicantId, forKey: "applicantId")
                    try container.encodeIfPresent(entities, forKey: "entities")
                }

            }
            public typealias SuccessType = [Status200]

            /** Search result */
            case status200([Status200])

            public var success: [Status200]? {
                switch self {
                case .status200(let response): return response
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode([Status200].self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
