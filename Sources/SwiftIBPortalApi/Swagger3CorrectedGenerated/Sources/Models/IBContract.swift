//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Contains all details of the contract, including rules you can use when placing orders */
public struct IBContract: APIModel {

    public let category: String?

    public let companyName: String?

    public let companyName: String?

    /** same as that in request */
    public let conId: String?

    public let currency: String?

    public let exchange: String?

    public let industry: String?

    /** for example STK */
    public let instrumentType: String?

    /** for exmple FB */
    public let localSymbol: String?

    /** true means you can trade outside RTH(regular trading hours) */
    public let rth: Bool?

    public let rules: Rules?

    /** Contains all details of the contract, including rules you can use when placing orders */
    public struct Rules: APIModel {

        /** default quantity you can use to place an order */
        public let defaultSize: Double?

        public let displaySize: String?

        public let increment: String?

        /** default limit price you can use to prefill your order */
        public let limitPrice: Double?

        public let orderTypes: [String]?

        public let orderTypesOutside: [String]?

        /** if you can preview the order or not with the whatif endpoint */
        public let preview: Bool?

        public let sizeIncrement: Double?

        /** default stop price you can use to prefill your order */
        public let stopprice: Double?

        public let tifTypes: [String]?

        public init(defaultSize: Double? = nil, displaySize: String? = nil, increment: String? = nil, limitPrice: Double? = nil, orderTypes: [String]? = nil, orderTypesOutside: [String]? = nil, preview: Bool? = nil, sizeIncrement: Double? = nil, stopprice: Double? = nil, tifTypes: [String]? = nil) {
            self.defaultSize = defaultSize
            self.displaySize = displaySize
            self.increment = increment
            self.limitPrice = limitPrice
            self.orderTypes = orderTypes
            self.orderTypesOutside = orderTypesOutside
            self.preview = preview
            self.sizeIncrement = sizeIncrement
            self.stopprice = stopprice
            self.tifTypes = tifTypes
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            defaultSize = try container.decodeIfPresent("defaultSize")
            displaySize = try container.decodeIfPresent("displaySize")
            increment = try container.decodeIfPresent("increment")
            limitPrice = try container.decodeIfPresent("limitPrice")
            orderTypes = try container.decodeArrayIfPresent("orderTypes")
            orderTypesOutside = try container.decodeArrayIfPresent("orderTypesOutside")
            preview = try container.decodeIfPresent("preview")
            sizeIncrement = try container.decodeIfPresent("sizeIncrement")
            stopprice = try container.decodeIfPresent("stopprice")
            tifTypes = try container.decodeArrayIfPresent("tifTypes")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(defaultSize, forKey: "defaultSize")
            try container.encodeIfPresent(displaySize, forKey: "displaySize")
            try container.encodeIfPresent(increment, forKey: "increment")
            try container.encodeIfPresent(limitPrice, forKey: "limitPrice")
            try container.encodeIfPresent(orderTypes, forKey: "orderTypes")
            try container.encodeIfPresent(orderTypesOutside, forKey: "orderTypesOutside")
            try container.encodeIfPresent(preview, forKey: "preview")
            try container.encodeIfPresent(sizeIncrement, forKey: "sizeIncrement")
            try container.encodeIfPresent(stopprice, forKey: "stopprice")
            try container.encodeIfPresent(tifTypes, forKey: "tifTypes")
        }

    }

    public init(category: String? = nil, companyName: String? = nil, companyName: String? = nil, conId: String? = nil, currency: String? = nil, exchange: String? = nil, industry: String? = nil, instrumentType: String? = nil, localSymbol: String? = nil, rth: Bool? = nil, rules: Rules? = nil) {
        self.category = category
        self.companyName = companyName
        self.companyName = companyName
        self.conId = conId
        self.currency = currency
        self.exchange = exchange
        self.industry = industry
        self.instrumentType = instrumentType
        self.localSymbol = localSymbol
        self.rth = rth
        self.rules = rules
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        category = try container.decodeIfPresent("category")
        companyName = try container.decodeIfPresent("companyName")
        companyName = try container.decodeIfPresent("company_name")
        conId = try container.decodeIfPresent("con_id")
        currency = try container.decodeIfPresent("currency")
        exchange = try container.decodeIfPresent("exchange")
        industry = try container.decodeIfPresent("industry")
        instrumentType = try container.decodeIfPresent("instrument_type")
        localSymbol = try container.decodeIfPresent("local_symbol")
        rth = try container.decodeIfPresent("r_t_h")
        rules = try container.decodeIfPresent("rules")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(category, forKey: "category")
        try container.encodeIfPresent(companyName, forKey: "companyName")
        try container.encodeIfPresent(companyName, forKey: "company_name")
        try container.encodeIfPresent(conId, forKey: "con_id")
        try container.encodeIfPresent(currency, forKey: "currency")
        try container.encodeIfPresent(exchange, forKey: "exchange")
        try container.encodeIfPresent(industry, forKey: "industry")
        try container.encodeIfPresent(instrumentType, forKey: "instrument_type")
        try container.encodeIfPresent(localSymbol, forKey: "local_symbol")
        try container.encodeIfPresent(rth, forKey: "r_t_h")
        try container.encodeIfPresent(rules, forKey: "rules")
    }

}
