//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class CalendarRequest: APIModel {

    public var date: Date?

    public var filters: Filters?

    public class Date: APIModel {

        /** end date of a period. for example 20180808-0400 */
        public var end: String?

        /** start date of a period. for example 20180808-0400 */
        public var start: String?

        public init(end: String? = nil, start: String? = nil) {
            self.end = end
            self.start = start
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            end = try container.decodeIfPresent("end")
            start = try container.decodeIfPresent("start")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(end, forKey: "end")
            try container.encodeIfPresent(start, forKey: "start")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Date else { return false }
          guard self.end == object.end else { return false }
          guard self.start == object.start else { return false }
          return true
        }

        public static func == (lhs: Date, rhs: Date) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class Filters: APIModel {

        /** value can be 'true' or 'false'. */
        public var divExDates: String?

        /** value can be 'true' or 'false'. */
        public var corporateEarnings: String?

        /** value can be 'true' or 'false'. */
        public var corporateEvents: String?

        /** default is 'All'. */
        public var country: String?

        /** value can be 'true' or 'false'. */
        public var economicEvents: String?

        /** value can be 'true' or 'false'. */
        public var ipo: String?

        /** default is '250'. */
        public var limit: String?

        /** default is '50'. */
        public var limitRegion: String?

        /** value can be 'true' or 'false'. */
        public var optionShowMonthly: String?

        /** value can be 'true' or 'false'. */
        public var optionShowWeekly: String?

        /** value can be 'true' or 'false'. */
        public var recentlyHeld: String?

        /** value can be 'true' or 'false'. */
        public var splits: String?

        public init(divExDates: String? = nil, corporateEarnings: String? = nil, corporateEvents: String? = nil, country: String? = nil, economicEvents: String? = nil, ipo: String? = nil, limit: String? = nil, limitRegion: String? = nil, optionShowMonthly: String? = nil, optionShowWeekly: String? = nil, recentlyHeld: String? = nil, splits: String? = nil) {
            self.divExDates = divExDates
            self.corporateEarnings = corporateEarnings
            self.corporateEvents = corporateEvents
            self.country = country
            self.economicEvents = economicEvents
            self.ipo = ipo
            self.limit = limit
            self.limitRegion = limitRegion
            self.optionShowMonthly = optionShowMonthly
            self.optionShowWeekly = optionShowWeekly
            self.recentlyHeld = recentlyHeld
            self.splits = splits
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            divExDates = try container.decodeIfPresent("DivExDates")
            corporateEarnings = try container.decodeIfPresent("corporate_earnings")
            corporateEvents = try container.decodeIfPresent("corporate_events")
            country = try container.decodeIfPresent("country")
            economicEvents = try container.decodeIfPresent("economic_events")
            ipo = try container.decodeIfPresent("ipo")
            limit = try container.decodeIfPresent("limit")
            limitRegion = try container.decodeIfPresent("limit_region")
            optionShowMonthly = try container.decodeIfPresent("option_show_monthly")
            optionShowWeekly = try container.decodeIfPresent("option_show_weekly")
            recentlyHeld = try container.decodeIfPresent("recently_held")
            splits = try container.decodeIfPresent("splits")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(divExDates, forKey: "DivExDates")
            try container.encodeIfPresent(corporateEarnings, forKey: "corporate_earnings")
            try container.encodeIfPresent(corporateEvents, forKey: "corporate_events")
            try container.encodeIfPresent(country, forKey: "country")
            try container.encodeIfPresent(economicEvents, forKey: "economic_events")
            try container.encodeIfPresent(ipo, forKey: "ipo")
            try container.encodeIfPresent(limit, forKey: "limit")
            try container.encodeIfPresent(limitRegion, forKey: "limit_region")
            try container.encodeIfPresent(optionShowMonthly, forKey: "option_show_monthly")
            try container.encodeIfPresent(optionShowWeekly, forKey: "option_show_weekly")
            try container.encodeIfPresent(recentlyHeld, forKey: "recently_held")
            try container.encodeIfPresent(splits, forKey: "splits")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Filters else { return false }
          guard self.divExDates == object.divExDates else { return false }
          guard self.corporateEarnings == object.corporateEarnings else { return false }
          guard self.corporateEvents == object.corporateEvents else { return false }
          guard self.country == object.country else { return false }
          guard self.economicEvents == object.economicEvents else { return false }
          guard self.ipo == object.ipo else { return false }
          guard self.limit == object.limit else { return false }
          guard self.limitRegion == object.limitRegion else { return false }
          guard self.optionShowMonthly == object.optionShowMonthly else { return false }
          guard self.optionShowWeekly == object.optionShowWeekly else { return false }
          guard self.recentlyHeld == object.recentlyHeld else { return false }
          guard self.splits == object.splits else { return false }
          return true
        }

        public static func == (lhs: Filters, rhs: Filters) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(date: Date? = nil, filters: Filters? = nil) {
        self.date = date
        self.filters = filters
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        date = try container.decodeIfPresent("date")
        filters = try container.decodeIfPresent("filters")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(date, forKey: "date")
        try container.encodeIfPresent(filters, forKey: "filters")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? CalendarRequest else { return false }
      guard self.date == object.date else { return false }
      guard self.filters == object.filters else { return false }
      return true
    }

    public static func == (lhs: CalendarRequest, rhs: CalendarRequest) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
