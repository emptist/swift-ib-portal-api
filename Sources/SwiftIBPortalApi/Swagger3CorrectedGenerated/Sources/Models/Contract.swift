//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Contains all details of the contract, including rules you can use when placing orders */
public class Contract: APIModel {

    public var category: String?

    public var companyName: String?

    public var companyName: String?

    /** same as that in request */
    public var conId: String?

    public var currency: String?

    public var exchange: String?

    public var industry: String?

    /** for example STK */
    public var instrumentType: String?

    /** for exmple FB */
    public var localSymbol: String?

    /** true means you can trade outside RTH(regular trading hours) */
    public var rth: Bool?

    public var rules: Rules?

    /** Contains all details of the contract, including rules you can use when placing orders */
    public class Rules: APIModel {

        /** default quantity you can use to place an order */
        public var defaultSize: Double?

        public var displaySize: String?

        public var increment: String?

        /** default limit price you can use to prefill your order */
        public var limitPrice: Double?

        public var orderTypes: [String]?

        public var orderTypesOutside: [String]?

        /** if you can preview the order or not with the whatif endpoint */
        public var preview: Bool?

        public var sizeIncrement: Double?

        /** default stop price you can use to prefill your order */
        public var stopprice: Double?

        public var tifTypes: [String]?

        public init(defaultSize: Double? = nil, displaySize: String? = nil, increment: String? = nil, limitPrice: Double? = nil, orderTypes: [String]? = nil, orderTypesOutside: [String]? = nil, preview: Bool? = nil, sizeIncrement: Double? = nil, stopprice: Double? = nil, tifTypes: [String]? = nil) {
            self.defaultSize = defaultSize
            self.displaySize = displaySize
            self.increment = increment
            self.limitPrice = limitPrice
            self.orderTypes = orderTypes
            self.orderTypesOutside = orderTypesOutside
            self.preview = preview
            self.sizeIncrement = sizeIncrement
            self.stopprice = stopprice
            self.tifTypes = tifTypes
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            defaultSize = try container.decodeIfPresent("defaultSize")
            displaySize = try container.decodeIfPresent("displaySize")
            increment = try container.decodeIfPresent("increment")
            limitPrice = try container.decodeIfPresent("limitPrice")
            orderTypes = try container.decodeArrayIfPresent("orderTypes")
            orderTypesOutside = try container.decodeArrayIfPresent("orderTypesOutside")
            preview = try container.decodeIfPresent("preview")
            sizeIncrement = try container.decodeIfPresent("sizeIncrement")
            stopprice = try container.decodeIfPresent("stopprice")
            tifTypes = try container.decodeArrayIfPresent("tifTypes")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(defaultSize, forKey: "defaultSize")
            try container.encodeIfPresent(displaySize, forKey: "displaySize")
            try container.encodeIfPresent(increment, forKey: "increment")
            try container.encodeIfPresent(limitPrice, forKey: "limitPrice")
            try container.encodeIfPresent(orderTypes, forKey: "orderTypes")
            try container.encodeIfPresent(orderTypesOutside, forKey: "orderTypesOutside")
            try container.encodeIfPresent(preview, forKey: "preview")
            try container.encodeIfPresent(sizeIncrement, forKey: "sizeIncrement")
            try container.encodeIfPresent(stopprice, forKey: "stopprice")
            try container.encodeIfPresent(tifTypes, forKey: "tifTypes")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Rules else { return false }
          guard self.defaultSize == object.defaultSize else { return false }
          guard self.displaySize == object.displaySize else { return false }
          guard self.increment == object.increment else { return false }
          guard self.limitPrice == object.limitPrice else { return false }
          guard self.orderTypes == object.orderTypes else { return false }
          guard self.orderTypesOutside == object.orderTypesOutside else { return false }
          guard self.preview == object.preview else { return false }
          guard self.sizeIncrement == object.sizeIncrement else { return false }
          guard self.stopprice == object.stopprice else { return false }
          guard self.tifTypes == object.tifTypes else { return false }
          return true
        }

        public static func == (lhs: Rules, rhs: Rules) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(category: String? = nil, companyName: String? = nil, companyName: String? = nil, conId: String? = nil, currency: String? = nil, exchange: String? = nil, industry: String? = nil, instrumentType: String? = nil, localSymbol: String? = nil, rth: Bool? = nil, rules: Rules? = nil) {
        self.category = category
        self.companyName = companyName
        self.companyName = companyName
        self.conId = conId
        self.currency = currency
        self.exchange = exchange
        self.industry = industry
        self.instrumentType = instrumentType
        self.localSymbol = localSymbol
        self.rth = rth
        self.rules = rules
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        category = try container.decodeIfPresent("category")
        companyName = try container.decodeIfPresent("companyName")
        companyName = try container.decodeIfPresent("company_name")
        conId = try container.decodeIfPresent("con_id")
        currency = try container.decodeIfPresent("currency")
        exchange = try container.decodeIfPresent("exchange")
        industry = try container.decodeIfPresent("industry")
        instrumentType = try container.decodeIfPresent("instrument_type")
        localSymbol = try container.decodeIfPresent("local_symbol")
        rth = try container.decodeIfPresent("r_t_h")
        rules = try container.decodeIfPresent("rules")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(category, forKey: "category")
        try container.encodeIfPresent(companyName, forKey: "companyName")
        try container.encodeIfPresent(companyName, forKey: "company_name")
        try container.encodeIfPresent(conId, forKey: "con_id")
        try container.encodeIfPresent(currency, forKey: "currency")
        try container.encodeIfPresent(exchange, forKey: "exchange")
        try container.encodeIfPresent(industry, forKey: "industry")
        try container.encodeIfPresent(instrumentType, forKey: "instrument_type")
        try container.encodeIfPresent(localSymbol, forKey: "local_symbol")
        try container.encodeIfPresent(rth, forKey: "r_t_h")
        try container.encodeIfPresent(rules, forKey: "rules")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? Contract else { return false }
      guard self.category == object.category else { return false }
      guard self.companyName == object.companyName else { return false }
      guard self.companyName == object.companyName else { return false }
      guard self.conId == object.conId else { return false }
      guard self.currency == object.currency else { return false }
      guard self.exchange == object.exchange else { return false }
      guard self.industry == object.industry else { return false }
      guard self.instrumentType == object.instrumentType else { return false }
      guard self.localSymbol == object.localSymbol else { return false }
      guard self.rth == object.rth else { return false }
      guard self.rules == object.rules else { return false }
      return true
    }

    public static func == (lhs: Contract, rhs: Contract) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
