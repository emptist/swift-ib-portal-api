//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public struct IBHistoryData: APIModel {

    /** The number of seconds in a bar */
    public let barLength: Int?

    public let data: [DataType]?

    /** High value during this time series with format %h/%v/%t. %h is the high price (scaled by priceFactor), %v is volume
(volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart
 */
    public let high: String?

    /** Low value during this time series with format %l/%v/%t. %l is the low price (scaled by priceFactor), %v is volume
(volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart
 */
    public let low: String?

    /** Market Data Availability. The field may contain two chars. The first char is the primary code: S = Streaming, R = Realtime, D = Delayed,
Z = Frozen, Y = Frozen Delayed. The second char is the secondary code: P = Snapshot Available, p = Consolidated.
 */
    public let mdAvailability: String?

    public let messageVersion: Int?

    /** The time it takes, in milliseconds, to process the historical data request */
    public let mktDataDelay: Int?

    public let negativeCapable: Bool?

    /** The historical data returned includes outside of regular trading hours
 */
    public let outsideRth: Bool?

    /** total number of points */
    public let points: Int?

    public let priceDisplayRule: Int?

    public let priceDisplayValue: String?

    /** priceFactor is price increment obtained from display rule */
    public let priceFactor: Int?

    /** start date time in the format YYYYMMDD-HH:mm:ss */
    public let startTime: String?

    /** Underlying Symbol of the corresponding contract */
    public let symbol: String?

    /** companyName of the corresponding contract */
    public let text: String?

    /** The duration for the historical data request */
    public let timePeriod: String?

    /** The number of seconds in the trading day */
    public let tradingDayDuration: Int?

    public let travelTime: Int?

    public let volumeFactor: Int?

    public struct DataType: APIModel {

        /** close price */
        public let c: Double?

        /** high price */
        public let h: Double?

        /** low price */
        public let l: Double?

        /** open price */
        public let o: Double?

        /** unix time stamp */
        public let t: Double?

        /** volume */
        public let v: Double?

        public init(c: Double? = nil, h: Double? = nil, l: Double? = nil, o: Double? = nil, t: Double? = nil, v: Double? = nil) {
            self.c = c
            self.h = h
            self.l = l
            self.o = o
            self.t = t
            self.v = v
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            c = try container.decodeIfPresent("c")
            h = try container.decodeIfPresent("h")
            l = try container.decodeIfPresent("l")
            o = try container.decodeIfPresent("o")
            t = try container.decodeIfPresent("t")
            v = try container.decodeIfPresent("v")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(c, forKey: "c")
            try container.encodeIfPresent(h, forKey: "h")
            try container.encodeIfPresent(l, forKey: "l")
            try container.encodeIfPresent(o, forKey: "o")
            try container.encodeIfPresent(t, forKey: "t")
            try container.encodeIfPresent(v, forKey: "v")
        }

    }

    public init(barLength: Int? = nil, data: [DataType]? = nil, high: String? = nil, low: String? = nil, mdAvailability: String? = nil, messageVersion: Int? = nil, mktDataDelay: Int? = nil, negativeCapable: Bool? = nil, outsideRth: Bool? = nil, points: Int? = nil, priceDisplayRule: Int? = nil, priceDisplayValue: String? = nil, priceFactor: Int? = nil, startTime: String? = nil, symbol: String? = nil, text: String? = nil, timePeriod: String? = nil, tradingDayDuration: Int? = nil, travelTime: Int? = nil, volumeFactor: Int? = nil) {
        self.barLength = barLength
        self.data = data
        self.high = high
        self.low = low
        self.mdAvailability = mdAvailability
        self.messageVersion = messageVersion
        self.mktDataDelay = mktDataDelay
        self.negativeCapable = negativeCapable
        self.outsideRth = outsideRth
        self.points = points
        self.priceDisplayRule = priceDisplayRule
        self.priceDisplayValue = priceDisplayValue
        self.priceFactor = priceFactor
        self.startTime = startTime
        self.symbol = symbol
        self.text = text
        self.timePeriod = timePeriod
        self.tradingDayDuration = tradingDayDuration
        self.travelTime = travelTime
        self.volumeFactor = volumeFactor
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        barLength = try container.decodeIfPresent("barLength")
        data = try container.decodeArrayIfPresent("data")
        high = try container.decodeIfPresent("high")
        low = try container.decodeIfPresent("low")
        mdAvailability = try container.decodeIfPresent("mdAvailability")
        messageVersion = try container.decodeIfPresent("messageVersion")
        mktDataDelay = try container.decodeIfPresent("mktDataDelay")
        negativeCapable = try container.decodeIfPresent("negativeCapable")
        outsideRth = try container.decodeIfPresent("outsideRth")
        points = try container.decodeIfPresent("points")
        priceDisplayRule = try container.decodeIfPresent("priceDisplayRule")
        priceDisplayValue = try container.decodeIfPresent("priceDisplayValue")
        priceFactor = try container.decodeIfPresent("priceFactor")
        startTime = try container.decodeIfPresent("startTime")
        symbol = try container.decodeIfPresent("symbol")
        text = try container.decodeIfPresent("text")
        timePeriod = try container.decodeIfPresent("timePeriod")
        tradingDayDuration = try container.decodeIfPresent("tradingDayDuration")
        travelTime = try container.decodeIfPresent("travelTime")
        volumeFactor = try container.decodeIfPresent("volumeFactor")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(barLength, forKey: "barLength")
        try container.encodeIfPresent(data, forKey: "data")
        try container.encodeIfPresent(high, forKey: "high")
        try container.encodeIfPresent(low, forKey: "low")
        try container.encodeIfPresent(mdAvailability, forKey: "mdAvailability")
        try container.encodeIfPresent(messageVersion, forKey: "messageVersion")
        try container.encodeIfPresent(mktDataDelay, forKey: "mktDataDelay")
        try container.encodeIfPresent(negativeCapable, forKey: "negativeCapable")
        try container.encodeIfPresent(outsideRth, forKey: "outsideRth")
        try container.encodeIfPresent(points, forKey: "points")
        try container.encodeIfPresent(priceDisplayRule, forKey: "priceDisplayRule")
        try container.encodeIfPresent(priceDisplayValue, forKey: "priceDisplayValue")
        try container.encodeIfPresent(priceFactor, forKey: "priceFactor")
        try container.encodeIfPresent(startTime, forKey: "startTime")
        try container.encodeIfPresent(symbol, forKey: "symbol")
        try container.encodeIfPresent(text, forKey: "text")
        try container.encodeIfPresent(timePeriod, forKey: "timePeriod")
        try container.encodeIfPresent(tradingDayDuration, forKey: "tradingDayDuration")
        try container.encodeIfPresent(travelTime, forKey: "travelTime")
        try container.encodeIfPresent(volumeFactor, forKey: "volumeFactor")
    }

}
