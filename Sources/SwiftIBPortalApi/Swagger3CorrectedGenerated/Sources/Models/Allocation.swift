//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** allocation */
public class Allocation: APIModel {

    /** portfolio allocation by asset class */
    public var assetClass: AssetClass?

    /** portfolio allocation by group */
    public var group: Group?

    /** portfolio allocation by sector */
    public var sector: Sector?

    /** portfolio allocation by asset class */
    public class AssetClass: APIModel {

        /** long positions allocation */
        public var long: Long?

        /** short positions allocation */
        public var short: Short?

        /** long positions allocation */
        public class Long: APIModel {

            public var bond: Double?

            public var cash: Double?

            public var fut: Double?

            public var opt: Double?

            public var stk: Double?

            public var war: Double?

            public init(bond: Double? = nil, cash: Double? = nil, fut: Double? = nil, opt: Double? = nil, stk: Double? = nil, war: Double? = nil) {
                self.bond = bond
                self.cash = cash
                self.fut = fut
                self.opt = opt
                self.stk = stk
                self.war = war
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                bond = try container.decodeIfPresent("BOND")
                cash = try container.decodeIfPresent("CASH")
                fut = try container.decodeIfPresent("FUT")
                opt = try container.decodeIfPresent("OPT")
                stk = try container.decodeIfPresent("STK")
                war = try container.decodeIfPresent("WAR")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(bond, forKey: "BOND")
                try container.encodeIfPresent(cash, forKey: "CASH")
                try container.encodeIfPresent(fut, forKey: "FUT")
                try container.encodeIfPresent(opt, forKey: "OPT")
                try container.encodeIfPresent(stk, forKey: "STK")
                try container.encodeIfPresent(war, forKey: "WAR")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Long else { return false }
              guard self.bond == object.bond else { return false }
              guard self.cash == object.cash else { return false }
              guard self.fut == object.fut else { return false }
              guard self.opt == object.opt else { return false }
              guard self.stk == object.stk else { return false }
              guard self.war == object.war else { return false }
              return true
            }

            public static func == (lhs: Long, rhs: Long) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        /** short positions allocation */
        public class Short: APIModel {

            public var bond: Double?

            public var cash: Double?

            public var fut: Double?

            public var opt: Double?

            public var stk: Double?

            public var war: Double?

            public init(bond: Double? = nil, cash: Double? = nil, fut: Double? = nil, opt: Double? = nil, stk: Double? = nil, war: Double? = nil) {
                self.bond = bond
                self.cash = cash
                self.fut = fut
                self.opt = opt
                self.stk = stk
                self.war = war
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                bond = try container.decodeIfPresent("BOND")
                cash = try container.decodeIfPresent("CASH")
                fut = try container.decodeIfPresent("FUT")
                opt = try container.decodeIfPresent("OPT")
                stk = try container.decodeIfPresent("STK")
                war = try container.decodeIfPresent("WAR")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(bond, forKey: "BOND")
                try container.encodeIfPresent(cash, forKey: "CASH")
                try container.encodeIfPresent(fut, forKey: "FUT")
                try container.encodeIfPresent(opt, forKey: "OPT")
                try container.encodeIfPresent(stk, forKey: "STK")
                try container.encodeIfPresent(war, forKey: "WAR")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Short else { return false }
              guard self.bond == object.bond else { return false }
              guard self.cash == object.cash else { return false }
              guard self.fut == object.fut else { return false }
              guard self.opt == object.opt else { return false }
              guard self.stk == object.stk else { return false }
              guard self.war == object.war else { return false }
              return true
            }

            public static func == (lhs: Short, rhs: Short) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(long: Long? = nil, short: Short? = nil) {
            self.long = long
            self.short = short
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            long = try container.decodeIfPresent("long")
            short = try container.decodeIfPresent("short")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(long, forKey: "long")
            try container.encodeIfPresent(short, forKey: "short")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? AssetClass else { return false }
          guard self.long == object.long else { return false }
          guard self.short == object.short else { return false }
          return true
        }

        public static func == (lhs: AssetClass, rhs: AssetClass) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** portfolio allocation by group */
    public class Group: APIModel {

        /** long positions allocation */
        public var long: Long?

        /** short positions allocation */
        public var short: Short?

        /** long positions allocation */
        public class Long: APIModel {

            public var apparel: Double?

            public var chemicals: Double?

            public var communications: Double?

            public var computers: Double?

            public var others: Double?

            public var semiconductors: Double?

            public init(apparel: Double? = nil, chemicals: Double? = nil, communications: Double? = nil, computers: Double? = nil, others: Double? = nil, semiconductors: Double? = nil) {
                self.apparel = apparel
                self.chemicals = chemicals
                self.communications = communications
                self.computers = computers
                self.others = others
                self.semiconductors = semiconductors
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                apparel = try container.decodeIfPresent("Apparel")
                chemicals = try container.decodeIfPresent("Chemicals")
                communications = try container.decodeIfPresent("Communications")
                computers = try container.decodeIfPresent("Computers")
                others = try container.decodeIfPresent("Others")
                semiconductors = try container.decodeIfPresent("Semiconductors")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(apparel, forKey: "Apparel")
                try container.encodeIfPresent(chemicals, forKey: "Chemicals")
                try container.encodeIfPresent(communications, forKey: "Communications")
                try container.encodeIfPresent(computers, forKey: "Computers")
                try container.encodeIfPresent(others, forKey: "Others")
                try container.encodeIfPresent(semiconductors, forKey: "Semiconductors")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Long else { return false }
              guard self.apparel == object.apparel else { return false }
              guard self.chemicals == object.chemicals else { return false }
              guard self.communications == object.communications else { return false }
              guard self.computers == object.computers else { return false }
              guard self.others == object.others else { return false }
              guard self.semiconductors == object.semiconductors else { return false }
              return true
            }

            public static func == (lhs: Long, rhs: Long) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        /** short positions allocation */
        public class Short: APIModel {

            public var airlines: Double?

            public var banks: Double?

            public var internet: Double?

            public init(airlines: Double? = nil, banks: Double? = nil, internet: Double? = nil) {
                self.airlines = airlines
                self.banks = banks
                self.internet = internet
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                airlines = try container.decodeIfPresent("Airlines")
                banks = try container.decodeIfPresent("Banks")
                internet = try container.decodeIfPresent("Internet")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(airlines, forKey: "Airlines")
                try container.encodeIfPresent(banks, forKey: "Banks")
                try container.encodeIfPresent(internet, forKey: "Internet")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Short else { return false }
              guard self.airlines == object.airlines else { return false }
              guard self.banks == object.banks else { return false }
              guard self.internet == object.internet else { return false }
              return true
            }

            public static func == (lhs: Short, rhs: Short) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(long: Long? = nil, short: Short? = nil) {
            self.long = long
            self.short = short
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            long = try container.decodeIfPresent("long")
            short = try container.decodeIfPresent("short")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(long, forKey: "long")
            try container.encodeIfPresent(short, forKey: "short")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Group else { return false }
          guard self.long == object.long else { return false }
          guard self.short == object.short else { return false }
          return true
        }

        public static func == (lhs: Group, rhs: Group) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** portfolio allocation by sector */
    public class Sector: APIModel {

        /** long positions allocation */
        public var long: Long?

        /** short positions allocation */
        public var short: Short?

        /** long positions allocation */
        public class Long: APIModel {

            public var communications: Double?

            public var energy: Double?

            public var financial: Double?

            public var others: Double?

            public var technology: Double?

            public var utilities: Double?

            public init(communications: Double? = nil, energy: Double? = nil, financial: Double? = nil, others: Double? = nil, technology: Double? = nil, utilities: Double? = nil) {
                self.communications = communications
                self.energy = energy
                self.financial = financial
                self.others = others
                self.technology = technology
                self.utilities = utilities
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                communications = try container.decodeIfPresent("Communications")
                energy = try container.decodeIfPresent("Energy")
                financial = try container.decodeIfPresent("Financial")
                others = try container.decodeIfPresent("Others")
                technology = try container.decodeIfPresent("Technology")
                utilities = try container.decodeIfPresent("Utilities")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(communications, forKey: "Communications")
                try container.encodeIfPresent(energy, forKey: "Energy")
                try container.encodeIfPresent(financial, forKey: "Financial")
                try container.encodeIfPresent(others, forKey: "Others")
                try container.encodeIfPresent(technology, forKey: "Technology")
                try container.encodeIfPresent(utilities, forKey: "Utilities")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Long else { return false }
              guard self.communications == object.communications else { return false }
              guard self.energy == object.energy else { return false }
              guard self.financial == object.financial else { return false }
              guard self.others == object.others else { return false }
              guard self.technology == object.technology else { return false }
              guard self.utilities == object.utilities else { return false }
              return true
            }

            public static func == (lhs: Long, rhs: Long) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        /** short positions allocation */
        public class Short: APIModel {

            public var consumer: Double?

            public var diversified: Double?

            public var industrial: Double?

            public init(consumer: Double? = nil, diversified: Double? = nil, industrial: Double? = nil) {
                self.consumer = consumer
                self.diversified = diversified
                self.industrial = industrial
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                consumer = try container.decodeIfPresent("Consumer")
                diversified = try container.decodeIfPresent("Diversified")
                industrial = try container.decodeIfPresent("Industrial")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(consumer, forKey: "Consumer")
                try container.encodeIfPresent(diversified, forKey: "Diversified")
                try container.encodeIfPresent(industrial, forKey: "Industrial")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Short else { return false }
              guard self.consumer == object.consumer else { return false }
              guard self.diversified == object.diversified else { return false }
              guard self.industrial == object.industrial else { return false }
              return true
            }

            public static func == (lhs: Short, rhs: Short) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(long: Long? = nil, short: Short? = nil) {
            self.long = long
            self.short = short
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            long = try container.decodeIfPresent("long")
            short = try container.decodeIfPresent("short")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(long, forKey: "long")
            try container.encodeIfPresent(short, forKey: "short")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Sector else { return false }
          guard self.long == object.long else { return false }
          guard self.short == object.short else { return false }
          return true
        }

        public static func == (lhs: Sector, rhs: Sector) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(assetClass: AssetClass? = nil, group: Group? = nil, sector: Sector? = nil) {
        self.assetClass = assetClass
        self.group = group
        self.sector = sector
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        assetClass = try container.decodeIfPresent("assetClass")
        group = try container.decodeIfPresent("group")
        sector = try container.decodeIfPresent("sector")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(assetClass, forKey: "assetClass")
        try container.encodeIfPresent(group, forKey: "group")
        try container.encodeIfPresent(sector, forKey: "sector")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? Allocation else { return false }
      guard self.assetClass == object.assetClass else { return false }
      guard self.group == object.group else { return false }
      guard self.sector == object.sector else { return false }
      return true
    }

    public static func == (lhs: Allocation, rhs: Allocation) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
