//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class Performance: APIModel {

    /** Cumulative performance data */
    public var cps: Cps?

    public var currencyType: String?

    public var id: String?

    public var included: [String]?

    /** Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks. */
    public var nav: Nav?

    public var pm: String?

    public var rc: Int?

    /** Time period performance data */
    public var tpps: Tpps?

    /** Cumulative performance data */
    public class Cps: APIModel {

        public var data: [DataType]?

        /** array of dates, the length should be same as the length of returns inside data. */
        public var dates: [String]?

        /** D means Day */
        public var freq: String?

        /** Cumulative performance data */
        public class DataType: APIModel {

            public var baseCurrency: String?

            /** end date-- yyyyMMdd */
            public var end: String?

            public var id: String?

            /** for example-- acctid */
            public var idType: String?

            /** each value stands for price change percent of corresponding date in dates array */
            public var returns: [Double]?

            /** start date-- yyyyMMdd */
            public var start: String?

            public init(baseCurrency: String? = nil, end: String? = nil, id: String? = nil, idType: String? = nil, returns: [Double]? = nil, start: String? = nil) {
                self.baseCurrency = baseCurrency
                self.end = end
                self.id = id
                self.idType = idType
                self.returns = returns
                self.start = start
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                baseCurrency = try container.decodeIfPresent("baseCurrency")
                end = try container.decodeIfPresent("end")
                id = try container.decodeIfPresent("id")
                idType = try container.decodeIfPresent("idType")
                returns = try container.decodeArrayIfPresent("returns")
                start = try container.decodeIfPresent("start")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(baseCurrency, forKey: "baseCurrency")
                try container.encodeIfPresent(end, forKey: "end")
                try container.encodeIfPresent(id, forKey: "id")
                try container.encodeIfPresent(idType, forKey: "idType")
                try container.encodeIfPresent(returns, forKey: "returns")
                try container.encodeIfPresent(start, forKey: "start")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? DataType else { return false }
              guard self.baseCurrency == object.baseCurrency else { return false }
              guard self.end == object.end else { return false }
              guard self.id == object.id else { return false }
              guard self.idType == object.idType else { return false }
              guard self.returns == object.returns else { return false }
              guard self.start == object.start else { return false }
              return true
            }

            public static func == (lhs: DataType, rhs: DataType) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(data: [DataType]? = nil, dates: [String]? = nil, freq: String? = nil) {
            self.data = data
            self.dates = dates
            self.freq = freq
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            data = try container.decodeArrayIfPresent("data")
            dates = try container.decodeArrayIfPresent("dates")
            freq = try container.decodeIfPresent("freq")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(data, forKey: "data")
            try container.encodeIfPresent(dates, forKey: "dates")
            try container.encodeIfPresent(freq, forKey: "freq")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Cps else { return false }
          guard self.data == object.data else { return false }
          guard self.dates == object.dates else { return false }
          guard self.freq == object.freq else { return false }
          return true
        }

        public static func == (lhs: Cps, rhs: Cps) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks. */
    public class Nav: APIModel {

        public var data: [DataType]?

        /** array of dates, the length should be same as the length of returns inside data. */
        public var dates: [String]?

        /** D means Day */
        public var freq: String?

        /** Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks. */
        public class DataType: APIModel {

            public var baseCurrency: String?

            /** end date-- yyyyMMdd */
            public var end: String?

            public var id: String?

            /** for example-- acctid */
            public var idType: String?

            /** each value stands for price change percent of corresponding date in dates array */
            public var returns: [Double]?

            /** start date-- yyyyMMdd */
            public var start: String?

            public init(baseCurrency: String? = nil, end: String? = nil, id: String? = nil, idType: String? = nil, returns: [Double]? = nil, start: String? = nil) {
                self.baseCurrency = baseCurrency
                self.end = end
                self.id = id
                self.idType = idType
                self.returns = returns
                self.start = start
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                baseCurrency = try container.decodeIfPresent("baseCurrency")
                end = try container.decodeIfPresent("end")
                id = try container.decodeIfPresent("id")
                idType = try container.decodeIfPresent("idType")
                returns = try container.decodeArrayIfPresent("returns")
                start = try container.decodeIfPresent("start")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(baseCurrency, forKey: "baseCurrency")
                try container.encodeIfPresent(end, forKey: "end")
                try container.encodeIfPresent(id, forKey: "id")
                try container.encodeIfPresent(idType, forKey: "idType")
                try container.encodeIfPresent(returns, forKey: "returns")
                try container.encodeIfPresent(start, forKey: "start")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? DataType else { return false }
              guard self.baseCurrency == object.baseCurrency else { return false }
              guard self.end == object.end else { return false }
              guard self.id == object.id else { return false }
              guard self.idType == object.idType else { return false }
              guard self.returns == object.returns else { return false }
              guard self.start == object.start else { return false }
              return true
            }

            public static func == (lhs: DataType, rhs: DataType) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(data: [DataType]? = nil, dates: [String]? = nil, freq: String? = nil) {
            self.data = data
            self.dates = dates
            self.freq = freq
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            data = try container.decodeArrayIfPresent("data")
            dates = try container.decodeArrayIfPresent("dates")
            freq = try container.decodeIfPresent("freq")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(data, forKey: "data")
            try container.encodeIfPresent(dates, forKey: "dates")
            try container.encodeIfPresent(freq, forKey: "freq")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Nav else { return false }
          guard self.data == object.data else { return false }
          guard self.dates == object.dates else { return false }
          guard self.freq == object.freq else { return false }
          return true
        }

        public static func == (lhs: Nav, rhs: Nav) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Time period performance data */
    public class Tpps: APIModel {

        public var data: [DataType]?

        /** array of dates, the length should be same as the length of returns inside data. */
        public var dates: [String]?

        /** M means Month */
        public var freq: String?

        /** Time period performance data */
        public class DataType: APIModel {

            public var baseCurrency: String?

            /** end date-- yyyyMMdd */
            public var end: String?

            public var id: String?

            /** for example-- acctid */
            public var idType: String?

            /** each value stands for price change percent of corresponding date in dates array */
            public var returns: [Double]?

            /** start date-- yyyyMMdd */
            public var start: String?

            public init(baseCurrency: String? = nil, end: String? = nil, id: String? = nil, idType: String? = nil, returns: [Double]? = nil, start: String? = nil) {
                self.baseCurrency = baseCurrency
                self.end = end
                self.id = id
                self.idType = idType
                self.returns = returns
                self.start = start
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                baseCurrency = try container.decodeIfPresent("baseCurrency")
                end = try container.decodeIfPresent("end")
                id = try container.decodeIfPresent("id")
                idType = try container.decodeIfPresent("idType")
                returns = try container.decodeArrayIfPresent("returns")
                start = try container.decodeIfPresent("start")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(baseCurrency, forKey: "baseCurrency")
                try container.encodeIfPresent(end, forKey: "end")
                try container.encodeIfPresent(id, forKey: "id")
                try container.encodeIfPresent(idType, forKey: "idType")
                try container.encodeIfPresent(returns, forKey: "returns")
                try container.encodeIfPresent(start, forKey: "start")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? DataType else { return false }
              guard self.baseCurrency == object.baseCurrency else { return false }
              guard self.end == object.end else { return false }
              guard self.id == object.id else { return false }
              guard self.idType == object.idType else { return false }
              guard self.returns == object.returns else { return false }
              guard self.start == object.start else { return false }
              return true
            }

            public static func == (lhs: DataType, rhs: DataType) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(data: [DataType]? = nil, dates: [String]? = nil, freq: String? = nil) {
            self.data = data
            self.dates = dates
            self.freq = freq
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            data = try container.decodeArrayIfPresent("data")
            dates = try container.decodeArrayIfPresent("dates")
            freq = try container.decodeIfPresent("freq")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(data, forKey: "data")
            try container.encodeIfPresent(dates, forKey: "dates")
            try container.encodeIfPresent(freq, forKey: "freq")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Tpps else { return false }
          guard self.data == object.data else { return false }
          guard self.dates == object.dates else { return false }
          guard self.freq == object.freq else { return false }
          return true
        }

        public static func == (lhs: Tpps, rhs: Tpps) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(cps: Cps? = nil, currencyType: String? = nil, id: String? = nil, included: [String]? = nil, nav: Nav? = nil, pm: String? = nil, rc: Int? = nil, tpps: Tpps? = nil) {
        self.cps = cps
        self.currencyType = currencyType
        self.id = id
        self.included = included
        self.nav = nav
        self.pm = pm
        self.rc = rc
        self.tpps = tpps
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        cps = try container.decodeIfPresent("cps")
        currencyType = try container.decodeIfPresent("currencyType")
        id = try container.decodeIfPresent("id")
        included = try container.decodeArrayIfPresent("included")
        nav = try container.decodeIfPresent("nav")
        pm = try container.decodeIfPresent("pm")
        rc = try container.decodeIfPresent("rc")
        tpps = try container.decodeIfPresent("tpps")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(cps, forKey: "cps")
        try container.encodeIfPresent(currencyType, forKey: "currencyType")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(included, forKey: "included")
        try container.encodeIfPresent(nav, forKey: "nav")
        try container.encodeIfPresent(pm, forKey: "pm")
        try container.encodeIfPresent(rc, forKey: "rc")
        try container.encodeIfPresent(tpps, forKey: "tpps")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? Performance else { return false }
      guard self.cps == object.cps else { return false }
      guard self.currencyType == object.currencyType else { return false }
      guard self.id == object.id else { return false }
      guard self.included == object.included else { return false }
      guard self.nav == object.nav else { return false }
      guard self.pm == object.pm else { return false }
      guard self.rc == object.rc else { return false }
      guard self.tpps == object.tpps else { return false }
      return true
    }

    public static func == (lhs: Performance, rhs: Performance) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
