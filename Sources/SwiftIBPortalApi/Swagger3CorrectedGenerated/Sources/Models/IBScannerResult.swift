//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public struct IBScannerResult: APIModel {

    /** Contains list of contracts matching the scanner query */
    public let contracts: Contracts?

    public let id: Double?

    public let offset: Int?

    public let position: String?

    public let scanTime: String?

    public let size: Int?

    public let total: Int?

    /** Contains list of contracts matching the scanner query */
    public struct Contracts: APIModel {

        public let contract: [Contract]?

        /** Contains list of contracts matching the scanner query */
        public struct Contract: APIModel {

            public let contractID: Int?

            public let distance: Int?

            public let inScanTime: String?

            public init(contractID: Int? = nil, distance: Int? = nil, inScanTime: String? = nil) {
                self.contractID = contractID
                self.distance = distance
                self.inScanTime = inScanTime
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                contractID = try container.decodeIfPresent("contractID")
                distance = try container.decodeIfPresent("distance")
                inScanTime = try container.decodeIfPresent("inScanTime")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(contractID, forKey: "contractID")
                try container.encodeIfPresent(distance, forKey: "distance")
                try container.encodeIfPresent(inScanTime, forKey: "inScanTime")
            }

        }

        public init(contract: [Contract]? = nil) {
            self.contract = contract
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            contract = try container.decodeArrayIfPresent("Contract")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(contract, forKey: "Contract")
        }

    }

    public init(contracts: Contracts? = nil, id: Double? = nil, offset: Int? = nil, position: String? = nil, scanTime: String? = nil, size: Int? = nil, total: Int? = nil) {
        self.contracts = contracts
        self.id = id
        self.offset = offset
        self.position = position
        self.scanTime = scanTime
        self.size = size
        self.total = total
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        contracts = try container.decodeIfPresent("Contracts")
        id = try container.decodeIfPresent("id")
        offset = try container.decodeIfPresent("offset")
        position = try container.decodeIfPresent("position")
        scanTime = try container.decodeIfPresent("scanTime")
        size = try container.decodeIfPresent("size")
        total = try container.decodeIfPresent("total")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(contracts, forKey: "Contracts")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(offset, forKey: "offset")
        try container.encodeIfPresent(position, forKey: "position")
        try container.encodeIfPresent(scanTime, forKey: "scanTime")
        try container.encodeIfPresent(size, forKey: "size")
        try container.encodeIfPresent(total, forKey: "total")
    }

}
