//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public struct IBAlertRequest: APIModel {

    /** The message you want to receive via email or text message */
    public let alertMessage: String?

    /** name of alert */
    public let alertName: String?

    /** whether alert is repeatable or not, so value can only be 0 or 1, this has to be 1 for MTA alert */
    public let alertRepeatable: Int?

    public let conditions: [Conditions]?

    /** email address to receive alert */
    public let email: String?

    /** format, YYYYMMDD-HH:mm:ss, please NOTE this will only work when tif is GTD
 */
    public let expireTime: String?

    /** value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile
 */
    public let iTWSOrdersOnly: Int?

    /** orderId is required when modifying alert. You can get it from /iserver/account/:accountId/alerts
 */
    public let orderId: Int?

    /** value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours.
 */
    public let outsideRth: Int?

    /** audio message to play when alert is triggered */
    public let playAudio: String?

    /** whether allowing to send email or not, so value can only be 0 or 1,
 */
    public let sendMessage: Int?

    /** value can only be 0 or 1, set to 1 to allow to show alert in pop-ups */
    public let showPopup: Int?

    /** time in force, can only be GTC or GTD */
    public let tif: String?

    /** for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert
 */
    public let toolId: Int?

    public struct Conditions: APIModel {

        /** format, conid@exchange */
        public let conidex: String?

        /** "a" means "AND", "o" means "OR", "n" means "END",
    the last one condition in the condition array should "n"
     */
        public let logicBind: String?

        /** optional, operator for the current condition, can be >= or <= */
        public let `operator`: String?

        /** only needed for some MTA alert condition */
        public let timeZone: String?

        /** optional, only some type of conditions have triggerMethod */
        public let triggerMethod: String?

        /** Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN&
     */
        public let type: Int?

        /** can not be empty, can pass default value "*" */
        public let value: String?

        public init(conidex: String? = nil, logicBind: String? = nil, `operator`: String? = nil, timeZone: String? = nil, triggerMethod: String? = nil, type: Int? = nil, value: String? = nil) {
            self.conidex = conidex
            self.logicBind = logicBind
            self.`operator` = `operator`
            self.timeZone = timeZone
            self.triggerMethod = triggerMethod
            self.type = type
            self.value = value
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            conidex = try container.decodeIfPresent("conidex")
            logicBind = try container.decodeIfPresent("logicBind")
            `operator` = try container.decodeIfPresent("operator")
            timeZone = try container.decodeIfPresent("timeZone")
            triggerMethod = try container.decodeIfPresent("triggerMethod")
            type = try container.decodeIfPresent("type")
            value = try container.decodeIfPresent("value")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(conidex, forKey: "conidex")
            try container.encodeIfPresent(logicBind, forKey: "logicBind")
            try container.encodeIfPresent(`operator`, forKey: "operator")
            try container.encodeIfPresent(timeZone, forKey: "timeZone")
            try container.encodeIfPresent(triggerMethod, forKey: "triggerMethod")
            try container.encodeIfPresent(type, forKey: "type")
            try container.encodeIfPresent(value, forKey: "value")
        }

    }

    public init(alertMessage: String? = nil, alertName: String? = nil, alertRepeatable: Int? = nil, conditions: [Conditions]? = nil, email: String? = nil, expireTime: String? = nil, iTWSOrdersOnly: Int? = nil, orderId: Int? = nil, outsideRth: Int? = nil, playAudio: String? = nil, sendMessage: Int? = nil, showPopup: Int? = nil, tif: String? = nil, toolId: Int? = nil) {
        self.alertMessage = alertMessage
        self.alertName = alertName
        self.alertRepeatable = alertRepeatable
        self.conditions = conditions
        self.email = email
        self.expireTime = expireTime
        self.iTWSOrdersOnly = iTWSOrdersOnly
        self.orderId = orderId
        self.outsideRth = outsideRth
        self.playAudio = playAudio
        self.sendMessage = sendMessage
        self.showPopup = showPopup
        self.tif = tif
        self.toolId = toolId
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        alertMessage = try container.decodeIfPresent("alertMessage")
        alertName = try container.decodeIfPresent("alertName")
        alertRepeatable = try container.decodeIfPresent("alertRepeatable")
        conditions = try container.decodeArrayIfPresent("conditions")
        email = try container.decodeIfPresent("email")
        expireTime = try container.decodeIfPresent("expireTime")
        iTWSOrdersOnly = try container.decodeIfPresent("iTWSOrdersOnly")
        orderId = try container.decodeIfPresent("orderId")
        outsideRth = try container.decodeIfPresent("outsideRth")
        playAudio = try container.decodeIfPresent("playAudio")
        sendMessage = try container.decodeIfPresent("sendMessage")
        showPopup = try container.decodeIfPresent("showPopup")
        tif = try container.decodeIfPresent("tif")
        toolId = try container.decodeIfPresent("toolId")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(alertMessage, forKey: "alertMessage")
        try container.encodeIfPresent(alertName, forKey: "alertName")
        try container.encodeIfPresent(alertRepeatable, forKey: "alertRepeatable")
        try container.encodeIfPresent(conditions, forKey: "conditions")
        try container.encodeIfPresent(email, forKey: "email")
        try container.encodeIfPresent(expireTime, forKey: "expireTime")
        try container.encodeIfPresent(iTWSOrdersOnly, forKey: "iTWSOrdersOnly")
        try container.encodeIfPresent(orderId, forKey: "orderId")
        try container.encodeIfPresent(outsideRth, forKey: "outsideRth")
        try container.encodeIfPresent(playAudio, forKey: "playAudio")
        try container.encodeIfPresent(sendMessage, forKey: "sendMessage")
        try container.encodeIfPresent(showPopup, forKey: "showPopup")
        try container.encodeIfPresent(tif, forKey: "tif")
        try container.encodeIfPresent(toolId, forKey: "toolId")
    }

}
